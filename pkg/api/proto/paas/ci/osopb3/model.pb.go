// Code generated by protoc-gen-gogo.
// source: paas/ci/osopb3/model.proto
// DO NOT EDIT!

package osopb3

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type K8SNamespacePhase int32

const (
	K8SNamespacePhase_Active      K8SNamespacePhase = 0
	K8SNamespacePhase_Terminating K8SNamespacePhase = 1
)

var K8SNamespacePhase_name = map[int32]string{
	0: "Active",
	1: "Terminating",
}
var K8SNamespacePhase_value = map[string]int32{
	"Active":      0,
	"Terminating": 1,
}

func (x K8SNamespacePhase) String() string {
	return proto.EnumName(K8SNamespacePhase_name, int32(x))
}
func (K8SNamespacePhase) EnumDescriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

type BuildStrategy_OsoBuildStrategyType int32

const (
	BuildStrategy_Docker          BuildStrategy_OsoBuildStrategyType = 0
	BuildStrategy_Source          BuildStrategy_OsoBuildStrategyType = 1
	BuildStrategy_Custom          BuildStrategy_OsoBuildStrategyType = 2
	BuildStrategy_JenkinsPipeline BuildStrategy_OsoBuildStrategyType = 3
)

var BuildStrategy_OsoBuildStrategyType_name = map[int32]string{
	0: "Docker",
	1: "Source",
	2: "Custom",
	3: "JenkinsPipeline",
}
var BuildStrategy_OsoBuildStrategyType_value = map[string]int32{
	"Docker":          0,
	"Source":          1,
	"Custom":          2,
	"JenkinsPipeline": 3,
}

func (x BuildStrategy_OsoBuildStrategyType) String() string {
	return proto.EnumName(BuildStrategy_OsoBuildStrategyType_name, int32(x))
}
func (BuildStrategy_OsoBuildStrategyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorModel, []int{25, 0}
}

type BuildSource_OsoBuildSourceType int32

const (
	BuildSource_Git        BuildSource_OsoBuildSourceType = 0
	BuildSource_Dockerfile BuildSource_OsoBuildSourceType = 1
	BuildSource_Binary     BuildSource_OsoBuildSourceType = 2
	BuildSource_Image      BuildSource_OsoBuildSourceType = 3
	BuildSource_None       BuildSource_OsoBuildSourceType = 4
)

var BuildSource_OsoBuildSourceType_name = map[int32]string{
	0: "Git",
	1: "Dockerfile",
	2: "Binary",
	3: "Image",
	4: "None",
}
var BuildSource_OsoBuildSourceType_value = map[string]int32{
	"Git":        0,
	"Dockerfile": 1,
	"Binary":     2,
	"Image":      3,
	"None":       4,
}

func (x BuildSource_OsoBuildSourceType) String() string {
	return proto.EnumName(BuildSource_OsoBuildSourceType_name, int32(x))
}
func (BuildSource_OsoBuildSourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorModel, []int{31, 0}
}

type OsoBuildTriggerPolicy_OsoBuildTriggerType int32

const (
	OsoBuildTriggerPolicy_GitHub       OsoBuildTriggerPolicy_OsoBuildTriggerType = 0
	OsoBuildTriggerPolicy_Generic      OsoBuildTriggerPolicy_OsoBuildTriggerType = 1
	OsoBuildTriggerPolicy_ImageChange  OsoBuildTriggerPolicy_OsoBuildTriggerType = 2
	OsoBuildTriggerPolicy_ConfigChange OsoBuildTriggerPolicy_OsoBuildTriggerType = 3
	OsoBuildTriggerPolicy_GoGits       OsoBuildTriggerPolicy_OsoBuildTriggerType = 4
)

var OsoBuildTriggerPolicy_OsoBuildTriggerType_name = map[int32]string{
	0: "GitHub",
	1: "Generic",
	2: "ImageChange",
	3: "ConfigChange",
	4: "GoGits",
}
var OsoBuildTriggerPolicy_OsoBuildTriggerType_value = map[string]int32{
	"GitHub":       0,
	"Generic":      1,
	"ImageChange":  2,
	"ConfigChange": 3,
	"GoGits":       4,
}

func (x OsoBuildTriggerPolicy_OsoBuildTriggerType) String() string {
	return proto.EnumName(OsoBuildTriggerPolicy_OsoBuildTriggerType_name, int32(x))
}
func (OsoBuildTriggerPolicy_OsoBuildTriggerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorModel, []int{35, 0}
}

type OsoBuildStatus_OsoBuildPhase int32

const (
	OsoBuildStatus_New       OsoBuildStatus_OsoBuildPhase = 0
	OsoBuildStatus_Pending   OsoBuildStatus_OsoBuildPhase = 1
	OsoBuildStatus_Running   OsoBuildStatus_OsoBuildPhase = 2
	OsoBuildStatus_Complete  OsoBuildStatus_OsoBuildPhase = 3
	OsoBuildStatus_Failed    OsoBuildStatus_OsoBuildPhase = 4
	OsoBuildStatus_Error     OsoBuildStatus_OsoBuildPhase = 5
	OsoBuildStatus_Cancelled OsoBuildStatus_OsoBuildPhase = 6
)

var OsoBuildStatus_OsoBuildPhase_name = map[int32]string{
	0: "New",
	1: "Pending",
	2: "Running",
	3: "Complete",
	4: "Failed",
	5: "Error",
	6: "Cancelled",
}
var OsoBuildStatus_OsoBuildPhase_value = map[string]int32{
	"New":       0,
	"Pending":   1,
	"Running":   2,
	"Complete":  3,
	"Failed":    4,
	"Error":     5,
	"Cancelled": 6,
}

func (x OsoBuildStatus_OsoBuildPhase) String() string {
	return proto.EnumName(OsoBuildStatus_OsoBuildPhase_name, int32(x))
}
func (OsoBuildStatus_OsoBuildPhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorModel, []int{40, 0}
}

//
// A copy of Kubernetes api
//
type K8STypeMeta struct {
	Kind       string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	ApiVersion string `protobuf:"bytes,2,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
}

func (m *K8STypeMeta) Reset()                    { *m = K8STypeMeta{} }
func (m *K8STypeMeta) String() string            { return proto.CompactTextString(m) }
func (*K8STypeMeta) ProtoMessage()               {}
func (*K8STypeMeta) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{0} }

type K8SListMeta struct {
	SelfLink        string `protobuf:"bytes,1,opt,name=selfLink,proto3" json:"selfLink,omitempty"`
	ResourceVersion string `protobuf:"bytes,2,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
}

func (m *K8SListMeta) Reset()                    { *m = K8SListMeta{} }
func (m *K8SListMeta) String() string            { return proto.CompactTextString(m) }
func (*K8SListMeta) ProtoMessage()               {}
func (*K8SListMeta) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{1} }

type K8SUnversionedTime struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *K8SUnversionedTime) Reset()                    { *m = K8SUnversionedTime{} }
func (m *K8SUnversionedTime) String() string            { return proto.CompactTextString(m) }
func (*K8SUnversionedTime) ProtoMessage()               {}
func (*K8SUnversionedTime) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{2} }

type K8SResourceQuantity struct {
	String_ string `protobuf:"bytes,1,opt,name=string,proto3" json:"string,omitempty"`
}

func (m *K8SResourceQuantity) Reset()                    { *m = K8SResourceQuantity{} }
func (m *K8SResourceQuantity) String() string            { return proto.CompactTextString(m) }
func (*K8SResourceQuantity) ProtoMessage()               {}
func (*K8SResourceQuantity) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{3} }

type OwnerReference struct {
	ApiVersion string `protobuf:"bytes,5,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	Kind       string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Name       string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uid        string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	Controller bool   `protobuf:"varint,6,opt,name=controller,proto3" json:"controller,omitempty"`
}

func (m *OwnerReference) Reset()                    { *m = OwnerReference{} }
func (m *OwnerReference) String() string            { return proto.CompactTextString(m) }
func (*OwnerReference) ProtoMessage()               {}
func (*OwnerReference) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{4} }

type K8SObjectMeta struct {
	Name                       string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	GenerateName               string              `protobuf:"bytes,2,opt,name=generateName,proto3" json:"generateName,omitempty"`
	Namespace                  string              `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	SelfLink                   string              `protobuf:"bytes,4,opt,name=selfLink,proto3" json:"selfLink,omitempty"`
	Uid                        string              `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty"`
	ResourceVersion            string              `protobuf:"bytes,6,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	Generation                 int64               `protobuf:"varint,7,opt,name=generation,proto3" json:"generation,omitempty"`
	CreationTimestamp          *K8SUnversionedTime `protobuf:"bytes,8,opt,name=creationTimestamp" json:"creationTimestamp,omitempty"`
	DeletionTimestamp          *K8SUnversionedTime `protobuf:"bytes,9,opt,name=deletionTimestamp" json:"deletionTimestamp,omitempty"`
	DeletionGracePeriodSeconds int64               `protobuf:"varint,10,opt,name=deletionGracePeriodSeconds,proto3" json:"deletionGracePeriodSeconds,omitempty"`
	Labels                     map[string]string   `protobuf:"bytes,11,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations                map[string]string   `protobuf:"bytes,12,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OwnerReferences            []*OwnerReference   `protobuf:"bytes,13,rep,name=ownerReferences" json:"ownerReferences,omitempty"`
	Finalizers                 []string            `protobuf:"bytes,14,rep,name=finalizers" json:"finalizers,omitempty"`
}

func (m *K8SObjectMeta) Reset()                    { *m = K8SObjectMeta{} }
func (m *K8SObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*K8SObjectMeta) ProtoMessage()               {}
func (*K8SObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{5} }

func (m *K8SObjectMeta) GetCreationTimestamp() *K8SUnversionedTime {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *K8SObjectMeta) GetDeletionTimestamp() *K8SUnversionedTime {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *K8SObjectMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *K8SObjectMeta) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *K8SObjectMeta) GetOwnerReferences() []*OwnerReference {
	if m != nil {
		return m.OwnerReferences
	}
	return nil
}

type K8SObjectReference struct {
	Kind            string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Namespace       string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name            string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uid             string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	ApiVersion      string `protobuf:"bytes,5,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	ResourceVersion string `protobuf:"bytes,6,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	FieldPath       string `protobuf:"bytes,7,opt,name=fieldPath,proto3" json:"fieldPath,omitempty"`
}

func (m *K8SObjectReference) Reset()                    { *m = K8SObjectReference{} }
func (m *K8SObjectReference) String() string            { return proto.CompactTextString(m) }
func (*K8SObjectReference) ProtoMessage()               {}
func (*K8SObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{6} }

type K8SLocalObjectReference struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *K8SLocalObjectReference) Reset()                    { *m = K8SLocalObjectReference{} }
func (m *K8SLocalObjectReference) String() string            { return proto.CompactTextString(m) }
func (*K8SLocalObjectReference) ProtoMessage()               {}
func (*K8SLocalObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{7} }

type K8SResourceRequirements struct {
	Limits   map[string]*K8SResourceQuantity `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Requests map[string]*K8SResourceQuantity `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *K8SResourceRequirements) Reset()                    { *m = K8SResourceRequirements{} }
func (m *K8SResourceRequirements) String() string            { return proto.CompactTextString(m) }
func (*K8SResourceRequirements) ProtoMessage()               {}
func (*K8SResourceRequirements) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{8} }

func (m *K8SResourceRequirements) GetLimits() map[string]*K8SResourceQuantity {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *K8SResourceRequirements) GetRequests() map[string]*K8SResourceQuantity {
	if m != nil {
		return m.Requests
	}
	return nil
}

type SecretKeySelector struct {
	LocalObjectReference *K8SLocalObjectReference `protobuf:"bytes,1,opt,name=localObjectReference" json:"localObjectReference,omitempty"`
	Key                  string                   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *SecretKeySelector) Reset()                    { *m = SecretKeySelector{} }
func (m *SecretKeySelector) String() string            { return proto.CompactTextString(m) }
func (*SecretKeySelector) ProtoMessage()               {}
func (*SecretKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{9} }

func (m *SecretKeySelector) GetLocalObjectReference() *K8SLocalObjectReference {
	if m != nil {
		return m.LocalObjectReference
	}
	return nil
}

type ConfigMapKeySelector struct {
	LocalObjectReference *K8SLocalObjectReference `protobuf:"bytes,1,opt,name=localObjectReference" json:"localObjectReference,omitempty"`
	Key                  string                   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ConfigMapKeySelector) Reset()                    { *m = ConfigMapKeySelector{} }
func (m *ConfigMapKeySelector) String() string            { return proto.CompactTextString(m) }
func (*ConfigMapKeySelector) ProtoMessage()               {}
func (*ConfigMapKeySelector) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{10} }

func (m *ConfigMapKeySelector) GetLocalObjectReference() *K8SLocalObjectReference {
	if m != nil {
		return m.LocalObjectReference
	}
	return nil
}

type ResourceFieldSelector struct {
	ContainerName string               `protobuf:"bytes,1,opt,name=containerName,proto3" json:"containerName,omitempty"`
	Resource      string               `protobuf:"bytes,2,opt,name=resource,proto3" json:"resource,omitempty"`
	Divisor       *K8SResourceQuantity `protobuf:"bytes,3,opt,name=divisor" json:"divisor,omitempty"`
}

func (m *ResourceFieldSelector) Reset()                    { *m = ResourceFieldSelector{} }
func (m *ResourceFieldSelector) String() string            { return proto.CompactTextString(m) }
func (*ResourceFieldSelector) ProtoMessage()               {}
func (*ResourceFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{11} }

func (m *ResourceFieldSelector) GetDivisor() *K8SResourceQuantity {
	if m != nil {
		return m.Divisor
	}
	return nil
}

type ObjectFieldSelector struct {
	ApiVersion string `protobuf:"bytes,1,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	FieldPath  string `protobuf:"bytes,2,opt,name=fieldPath,proto3" json:"fieldPath,omitempty"`
}

func (m *ObjectFieldSelector) Reset()                    { *m = ObjectFieldSelector{} }
func (m *ObjectFieldSelector) String() string            { return proto.CompactTextString(m) }
func (*ObjectFieldSelector) ProtoMessage()               {}
func (*ObjectFieldSelector) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{12} }

type EnvVarSource struct {
	FieldRef         *ObjectFieldSelector   `protobuf:"bytes,1,opt,name=fieldRef" json:"fieldRef,omitempty"`
	ResourceFieldRef *ResourceFieldSelector `protobuf:"bytes,2,opt,name=resourceFieldRef" json:"resourceFieldRef,omitempty"`
	ConfigMapKeyRef  *ConfigMapKeySelector  `protobuf:"bytes,3,opt,name=configMapKeyRef" json:"configMapKeyRef,omitempty"`
	SecretKeyRef     *SecretKeySelector     `protobuf:"bytes,4,opt,name=secretKeyRef" json:"secretKeyRef,omitempty"`
}

func (m *EnvVarSource) Reset()                    { *m = EnvVarSource{} }
func (m *EnvVarSource) String() string            { return proto.CompactTextString(m) }
func (*EnvVarSource) ProtoMessage()               {}
func (*EnvVarSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{13} }

func (m *EnvVarSource) GetFieldRef() *ObjectFieldSelector {
	if m != nil {
		return m.FieldRef
	}
	return nil
}

func (m *EnvVarSource) GetResourceFieldRef() *ResourceFieldSelector {
	if m != nil {
		return m.ResourceFieldRef
	}
	return nil
}

func (m *EnvVarSource) GetConfigMapKeyRef() *ConfigMapKeySelector {
	if m != nil {
		return m.ConfigMapKeyRef
	}
	return nil
}

func (m *EnvVarSource) GetSecretKeyRef() *SecretKeySelector {
	if m != nil {
		return m.SecretKeyRef
	}
	return nil
}

type K8SEnvVar struct {
	Name      string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value     string        `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	ValueFrom *EnvVarSource `protobuf:"bytes,3,opt,name=valueFrom" json:"valueFrom,omitempty"`
}

func (m *K8SEnvVar) Reset()                    { *m = K8SEnvVar{} }
func (m *K8SEnvVar) String() string            { return proto.CompactTextString(m) }
func (*K8SEnvVar) ProtoMessage()               {}
func (*K8SEnvVar) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{14} }

func (m *K8SEnvVar) GetValueFrom() *EnvVarSource {
	if m != nil {
		return m.ValueFrom
	}
	return nil
}

//
// A copy of OpenShift Build Protobuf
//
type SourceControlUser struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *SourceControlUser) Reset()                    { *m = SourceControlUser{} }
func (m *SourceControlUser) String() string            { return proto.CompactTextString(m) }
func (*SourceControlUser) ProtoMessage()               {}
func (*SourceControlUser) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{15} }

type GitSourceRevision struct {
	Commit    string             `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Author    *SourceControlUser `protobuf:"bytes,2,opt,name=author" json:"author,omitempty"`
	Committer *SourceControlUser `protobuf:"bytes,3,opt,name=committer" json:"committer,omitempty"`
	Message   string             `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *GitSourceRevision) Reset()                    { *m = GitSourceRevision{} }
func (m *GitSourceRevision) String() string            { return proto.CompactTextString(m) }
func (*GitSourceRevision) ProtoMessage()               {}
func (*GitSourceRevision) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{16} }

func (m *GitSourceRevision) GetAuthor() *SourceControlUser {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *GitSourceRevision) GetCommitter() *SourceControlUser {
	if m != nil {
		return m.Committer
	}
	return nil
}

type SourceRevision struct {
	Type string             `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Git  *GitSourceRevision `protobuf:"bytes,2,opt,name=git" json:"git,omitempty"`
}

func (m *SourceRevision) Reset()                    { *m = SourceRevision{} }
func (m *SourceRevision) String() string            { return proto.CompactTextString(m) }
func (*SourceRevision) ProtoMessage()               {}
func (*SourceRevision) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{17} }

func (m *SourceRevision) GetGit() *GitSourceRevision {
	if m != nil {
		return m.Git
	}
	return nil
}

type BuildPostCommitSpec struct {
	Command []string `protobuf:"bytes,1,rep,name=command" json:"command,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Script  string   `protobuf:"bytes,3,opt,name=script,proto3" json:"script,omitempty"`
}

func (m *BuildPostCommitSpec) Reset()                    { *m = BuildPostCommitSpec{} }
func (m *BuildPostCommitSpec) String() string            { return proto.CompactTextString(m) }
func (*BuildPostCommitSpec) ProtoMessage()               {}
func (*BuildPostCommitSpec) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{18} }

type BuildOutput struct {
	To         *K8SObjectReference      `protobuf:"bytes,1,opt,name=to" json:"to,omitempty"`
	PushSecret *K8SLocalObjectReference `protobuf:"bytes,2,opt,name=pushSecret" json:"pushSecret,omitempty"`
}

func (m *BuildOutput) Reset()                    { *m = BuildOutput{} }
func (m *BuildOutput) String() string            { return proto.CompactTextString(m) }
func (*BuildOutput) ProtoMessage()               {}
func (*BuildOutput) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{19} }

func (m *BuildOutput) GetTo() *K8SObjectReference {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *BuildOutput) GetPushSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.PushSecret
	}
	return nil
}

type JenkinsPipelineBuildStrategy struct {
	JenkinsfilePath string `protobuf:"bytes,1,opt,name=jenkinsfilePath,proto3" json:"jenkinsfilePath,omitempty"`
	Jenkinsfile     string `protobuf:"bytes,2,opt,name=jenkinsfile,proto3" json:"jenkinsfile,omitempty"`
}

func (m *JenkinsPipelineBuildStrategy) Reset()         { *m = JenkinsPipelineBuildStrategy{} }
func (m *JenkinsPipelineBuildStrategy) String() string { return proto.CompactTextString(m) }
func (*JenkinsPipelineBuildStrategy) ProtoMessage()    {}
func (*JenkinsPipelineBuildStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptorModel, []int{20}
}

type SecretSpec struct {
	SecretSource *K8SLocalObjectReference `protobuf:"bytes,1,opt,name=secretSource" json:"secretSource,omitempty"`
	MountPath    string                   `protobuf:"bytes,2,opt,name=mountPath,proto3" json:"mountPath,omitempty"`
}

func (m *SecretSpec) Reset()                    { *m = SecretSpec{} }
func (m *SecretSpec) String() string            { return proto.CompactTextString(m) }
func (*SecretSpec) ProtoMessage()               {}
func (*SecretSpec) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{21} }

func (m *SecretSpec) GetSecretSource() *K8SLocalObjectReference {
	if m != nil {
		return m.SecretSource
	}
	return nil
}

type CustomBuildStrategy struct {
	From               *K8SObjectReference      `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	PullSecret         *K8SLocalObjectReference `protobuf:"bytes,2,opt,name=pullSecret" json:"pullSecret,omitempty"`
	Env                []*K8SEnvVar             `protobuf:"bytes,3,rep,name=env" json:"env,omitempty"`
	ExposeDockerSocket bool                     `protobuf:"varint,4,opt,name=exposeDockerSocket,proto3" json:"exposeDockerSocket,omitempty"`
	ForcePull          bool                     `protobuf:"varint,5,opt,name=forcePull,proto3" json:"forcePull,omitempty"`
	Secrets            []*SecretSpec            `protobuf:"bytes,6,rep,name=secrets" json:"secrets,omitempty"`
	BuildAPIVersion    string                   `protobuf:"bytes,7,opt,name=buildAPIVersion,proto3" json:"buildAPIVersion,omitempty"`
}

func (m *CustomBuildStrategy) Reset()                    { *m = CustomBuildStrategy{} }
func (m *CustomBuildStrategy) String() string            { return proto.CompactTextString(m) }
func (*CustomBuildStrategy) ProtoMessage()               {}
func (*CustomBuildStrategy) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{22} }

func (m *CustomBuildStrategy) GetFrom() *K8SObjectReference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *CustomBuildStrategy) GetPullSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.PullSecret
	}
	return nil
}

func (m *CustomBuildStrategy) GetEnv() []*K8SEnvVar {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *CustomBuildStrategy) GetSecrets() []*SecretSpec {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type SourceBuildStrategy struct {
	From        *K8SObjectReference      `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	PullSecret  *K8SLocalObjectReference `protobuf:"bytes,2,opt,name=pullSecret" json:"pullSecret,omitempty"`
	Env         []*K8SEnvVar             `protobuf:"bytes,3,rep,name=env" json:"env,omitempty"`
	Scripts     string                   `protobuf:"bytes,4,opt,name=scripts,proto3" json:"scripts,omitempty"`
	Incremental bool                     `protobuf:"varint,5,opt,name=incremental,proto3" json:"incremental,omitempty"`
	ForcePull   bool                     `protobuf:"varint,6,opt,name=forcePull,proto3" json:"forcePull,omitempty"`
}

func (m *SourceBuildStrategy) Reset()                    { *m = SourceBuildStrategy{} }
func (m *SourceBuildStrategy) String() string            { return proto.CompactTextString(m) }
func (*SourceBuildStrategy) ProtoMessage()               {}
func (*SourceBuildStrategy) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{23} }

func (m *SourceBuildStrategy) GetFrom() *K8SObjectReference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SourceBuildStrategy) GetPullSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.PullSecret
	}
	return nil
}

func (m *SourceBuildStrategy) GetEnv() []*K8SEnvVar {
	if m != nil {
		return m.Env
	}
	return nil
}

type DockerBuildStrategy struct {
	From           *K8SObjectReference      `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	PullSecret     *K8SLocalObjectReference `protobuf:"bytes,2,opt,name=pullSecret" json:"pullSecret,omitempty"`
	NoCache        bool                     `protobuf:"varint,3,opt,name=noCache,proto3" json:"noCache,omitempty"`
	Env            []*K8SEnvVar             `protobuf:"bytes,4,rep,name=env" json:"env,omitempty"`
	ForcePull      bool                     `protobuf:"varint,5,opt,name=forcePull,proto3" json:"forcePull,omitempty"`
	DockerfilePath string                   `protobuf:"bytes,6,opt,name=dockerfilePath,proto3" json:"dockerfilePath,omitempty"`
}

func (m *DockerBuildStrategy) Reset()                    { *m = DockerBuildStrategy{} }
func (m *DockerBuildStrategy) String() string            { return proto.CompactTextString(m) }
func (*DockerBuildStrategy) ProtoMessage()               {}
func (*DockerBuildStrategy) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{24} }

func (m *DockerBuildStrategy) GetFrom() *K8SObjectReference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *DockerBuildStrategy) GetPullSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.PullSecret
	}
	return nil
}

func (m *DockerBuildStrategy) GetEnv() []*K8SEnvVar {
	if m != nil {
		return m.Env
	}
	return nil
}

type BuildStrategy struct {
	Type                    string                             `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	DockerStrategy          *DockerBuildStrategy               `protobuf:"bytes,2,opt,name=dockerStrategy" json:"dockerStrategy,omitempty"`
	SourceStrategy          *SourceBuildStrategy               `protobuf:"bytes,3,opt,name=sourceStrategy" json:"sourceStrategy,omitempty"`
	CustomStrategy          *CustomBuildStrategy               `protobuf:"bytes,4,opt,name=customStrategy" json:"customStrategy,omitempty"`
	JenkinsPipelineStrategy *JenkinsPipelineBuildStrategy      `protobuf:"bytes,5,opt,name=jenkinsPipelineStrategy" json:"jenkinsPipelineStrategy,omitempty"`
	OsoBuildStrategyType    BuildStrategy_OsoBuildStrategyType `protobuf:"varint,6,opt,name=osoBuildStrategyType,proto3,enum=paas.ci.osopb3.BuildStrategy_OsoBuildStrategyType" json:"osoBuildStrategyType,omitempty"`
}

func (m *BuildStrategy) Reset()                    { *m = BuildStrategy{} }
func (m *BuildStrategy) String() string            { return proto.CompactTextString(m) }
func (*BuildStrategy) ProtoMessage()               {}
func (*BuildStrategy) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{25} }

func (m *BuildStrategy) GetDockerStrategy() *DockerBuildStrategy {
	if m != nil {
		return m.DockerStrategy
	}
	return nil
}

func (m *BuildStrategy) GetSourceStrategy() *SourceBuildStrategy {
	if m != nil {
		return m.SourceStrategy
	}
	return nil
}

func (m *BuildStrategy) GetCustomStrategy() *CustomBuildStrategy {
	if m != nil {
		return m.CustomStrategy
	}
	return nil
}

func (m *BuildStrategy) GetJenkinsPipelineStrategy() *JenkinsPipelineBuildStrategy {
	if m != nil {
		return m.JenkinsPipelineStrategy
	}
	return nil
}

type SecretBuildSource struct {
	Secret         *K8SLocalObjectReference `protobuf:"bytes,1,opt,name=secret" json:"secret,omitempty"`
	DestinationDir string                   `protobuf:"bytes,2,opt,name=destinationDir,proto3" json:"destinationDir,omitempty"`
}

func (m *SecretBuildSource) Reset()                    { *m = SecretBuildSource{} }
func (m *SecretBuildSource) String() string            { return proto.CompactTextString(m) }
func (*SecretBuildSource) ProtoMessage()               {}
func (*SecretBuildSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{26} }

func (m *SecretBuildSource) GetSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.Secret
	}
	return nil
}

type ImageSourcePath struct {
	SourcePath     string `protobuf:"bytes,1,opt,name=sourcePath,proto3" json:"sourcePath,omitempty"`
	DestinationDir string `protobuf:"bytes,2,opt,name=destinationDir,proto3" json:"destinationDir,omitempty"`
}

func (m *ImageSourcePath) Reset()                    { *m = ImageSourcePath{} }
func (m *ImageSourcePath) String() string            { return proto.CompactTextString(m) }
func (*ImageSourcePath) ProtoMessage()               {}
func (*ImageSourcePath) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{27} }

type ImageSource struct {
	From       *K8SObjectReference      `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	Paths      []*ImageSourcePath       `protobuf:"bytes,2,rep,name=paths" json:"paths,omitempty"`
	PullSecret *K8SLocalObjectReference `protobuf:"bytes,3,opt,name=pullSecret" json:"pullSecret,omitempty"`
}

func (m *ImageSource) Reset()                    { *m = ImageSource{} }
func (m *ImageSource) String() string            { return proto.CompactTextString(m) }
func (*ImageSource) ProtoMessage()               {}
func (*ImageSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{28} }

func (m *ImageSource) GetFrom() *K8SObjectReference {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ImageSource) GetPaths() []*ImageSourcePath {
	if m != nil {
		return m.Paths
	}
	return nil
}

func (m *ImageSource) GetPullSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.PullSecret
	}
	return nil
}

type GitBuildSource struct {
	Uri        string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Ref        string `protobuf:"bytes,2,opt,name=ref,proto3" json:"ref,omitempty"`
	HttpProxy  string `protobuf:"bytes,3,opt,name=httpProxy,proto3" json:"httpProxy,omitempty"`
	HttpsProxy string `protobuf:"bytes,4,opt,name=httpsProxy,proto3" json:"httpsProxy,omitempty"`
}

func (m *GitBuildSource) Reset()                    { *m = GitBuildSource{} }
func (m *GitBuildSource) String() string            { return proto.CompactTextString(m) }
func (*GitBuildSource) ProtoMessage()               {}
func (*GitBuildSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{29} }

type BinaryBuildSource struct {
	AsFile string `protobuf:"bytes,1,opt,name=asFile,proto3" json:"asFile,omitempty"`
}

func (m *BinaryBuildSource) Reset()                    { *m = BinaryBuildSource{} }
func (m *BinaryBuildSource) String() string            { return proto.CompactTextString(m) }
func (*BinaryBuildSource) ProtoMessage()               {}
func (*BinaryBuildSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{30} }

type BuildSource struct {
	Type               string                         `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Binary             *BinaryBuildSource             `protobuf:"bytes,2,opt,name=binary" json:"binary,omitempty"`
	Dockerfile         string                         `protobuf:"bytes,3,opt,name=dockerfile,proto3" json:"dockerfile,omitempty"`
	Git                *GitBuildSource                `protobuf:"bytes,4,opt,name=git" json:"git,omitempty"`
	Images             []*ImageSource                 `protobuf:"bytes,5,rep,name=images" json:"images,omitempty"`
	ContextDir         string                         `protobuf:"bytes,6,opt,name=contextDir,proto3" json:"contextDir,omitempty"`
	SourceSecret       *K8SLocalObjectReference       `protobuf:"bytes,7,opt,name=sourceSecret" json:"sourceSecret,omitempty"`
	Secrets            []*SecretBuildSource           `protobuf:"bytes,8,rep,name=secrets" json:"secrets,omitempty"`
	OsoBuildSourceType BuildSource_OsoBuildSourceType `protobuf:"varint,9,opt,name=osoBuildSourceType,proto3,enum=paas.ci.osopb3.BuildSource_OsoBuildSourceType" json:"osoBuildSourceType,omitempty"`
}

func (m *BuildSource) Reset()                    { *m = BuildSource{} }
func (m *BuildSource) String() string            { return proto.CompactTextString(m) }
func (*BuildSource) ProtoMessage()               {}
func (*BuildSource) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{31} }

func (m *BuildSource) GetBinary() *BinaryBuildSource {
	if m != nil {
		return m.Binary
	}
	return nil
}

func (m *BuildSource) GetGit() *GitBuildSource {
	if m != nil {
		return m.Git
	}
	return nil
}

func (m *BuildSource) GetImages() []*ImageSource {
	if m != nil {
		return m.Images
	}
	return nil
}

func (m *BuildSource) GetSourceSecret() *K8SLocalObjectReference {
	if m != nil {
		return m.SourceSecret
	}
	return nil
}

func (m *BuildSource) GetSecrets() []*SecretBuildSource {
	if m != nil {
		return m.Secrets
	}
	return nil
}

type OsoCommonSpec struct {
	ServiceAccount            string                   `protobuf:"bytes,1,opt,name=serviceAccount,proto3" json:"serviceAccount,omitempty"`
	Source                    *BuildSource             `protobuf:"bytes,2,opt,name=source" json:"source,omitempty"`
	Revision                  *SourceRevision          `protobuf:"bytes,3,opt,name=revision" json:"revision,omitempty"`
	Strategy                  *BuildStrategy           `protobuf:"bytes,4,opt,name=strategy" json:"strategy,omitempty"`
	Output                    *BuildOutput             `protobuf:"bytes,5,opt,name=output" json:"output,omitempty"`
	Resources                 *K8SResourceRequirements `protobuf:"bytes,6,opt,name=resources" json:"resources,omitempty"`
	PostCommit                *BuildPostCommitSpec     `protobuf:"bytes,7,opt,name=postCommit" json:"postCommit,omitempty"`
	CompletionDeadlineSeconds int64                    `protobuf:"varint,8,opt,name=completionDeadlineSeconds,proto3" json:"completionDeadlineSeconds,omitempty"`
}

func (m *OsoCommonSpec) Reset()                    { *m = OsoCommonSpec{} }
func (m *OsoCommonSpec) String() string            { return proto.CompactTextString(m) }
func (*OsoCommonSpec) ProtoMessage()               {}
func (*OsoCommonSpec) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{32} }

func (m *OsoCommonSpec) GetSource() *BuildSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *OsoCommonSpec) GetRevision() *SourceRevision {
	if m != nil {
		return m.Revision
	}
	return nil
}

func (m *OsoCommonSpec) GetStrategy() *BuildStrategy {
	if m != nil {
		return m.Strategy
	}
	return nil
}

func (m *OsoCommonSpec) GetOutput() *BuildOutput {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OsoCommonSpec) GetResources() *K8SResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *OsoCommonSpec) GetPostCommit() *BuildPostCommitSpec {
	if m != nil {
		return m.PostCommit
	}
	return nil
}

type WebHookTrigger struct {
	Secret   string `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	AllowEnv bool   `protobuf:"varint,2,opt,name=allowEnv,proto3" json:"allowEnv,omitempty"`
}

func (m *WebHookTrigger) Reset()                    { *m = WebHookTrigger{} }
func (m *WebHookTrigger) String() string            { return proto.CompactTextString(m) }
func (*WebHookTrigger) ProtoMessage()               {}
func (*WebHookTrigger) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{33} }

type ImageChangeTrigger struct {
	LastTriggeredImageID string              `protobuf:"bytes,1,opt,name=lastTriggeredImageID,proto3" json:"lastTriggeredImageID,omitempty"`
	From                 *K8SObjectReference `protobuf:"bytes,2,opt,name=from" json:"from,omitempty"`
}

func (m *ImageChangeTrigger) Reset()                    { *m = ImageChangeTrigger{} }
func (m *ImageChangeTrigger) String() string            { return proto.CompactTextString(m) }
func (*ImageChangeTrigger) ProtoMessage()               {}
func (*ImageChangeTrigger) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{34} }

func (m *ImageChangeTrigger) GetFrom() *K8SObjectReference {
	if m != nil {
		return m.From
	}
	return nil
}

type OsoBuildTriggerPolicy struct {
	Type                string                                    `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Github              *WebHookTrigger                           `protobuf:"bytes,2,opt,name=github" json:"github,omitempty"`
	Generic             *WebHookTrigger                           `protobuf:"bytes,3,opt,name=generic" json:"generic,omitempty"`
	ImageChange         *ImageChangeTrigger                       `protobuf:"bytes,4,opt,name=imageChange" json:"imageChange,omitempty"`
	OsoBuildTriggerType OsoBuildTriggerPolicy_OsoBuildTriggerType `protobuf:"varint,5,opt,name=osoBuildTriggerType,proto3,enum=paas.ci.osopb3.OsoBuildTriggerPolicy_OsoBuildTriggerType" json:"osoBuildTriggerType,omitempty"`
}

func (m *OsoBuildTriggerPolicy) Reset()                    { *m = OsoBuildTriggerPolicy{} }
func (m *OsoBuildTriggerPolicy) String() string            { return proto.CompactTextString(m) }
func (*OsoBuildTriggerPolicy) ProtoMessage()               {}
func (*OsoBuildTriggerPolicy) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{35} }

func (m *OsoBuildTriggerPolicy) GetGithub() *WebHookTrigger {
	if m != nil {
		return m.Github
	}
	return nil
}

func (m *OsoBuildTriggerPolicy) GetGeneric() *WebHookTrigger {
	if m != nil {
		return m.Generic
	}
	return nil
}

func (m *OsoBuildTriggerPolicy) GetImageChange() *ImageChangeTrigger {
	if m != nil {
		return m.ImageChange
	}
	return nil
}

type GenericWebHookCause struct {
	Revision *SourceRevision `protobuf:"bytes,1,opt,name=revision" json:"revision,omitempty"`
	Secret   string          `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *GenericWebHookCause) Reset()                    { *m = GenericWebHookCause{} }
func (m *GenericWebHookCause) String() string            { return proto.CompactTextString(m) }
func (*GenericWebHookCause) ProtoMessage()               {}
func (*GenericWebHookCause) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{36} }

func (m *GenericWebHookCause) GetRevision() *SourceRevision {
	if m != nil {
		return m.Revision
	}
	return nil
}

type GitHubWebHookCause struct {
	Revision *SourceRevision `protobuf:"bytes,1,opt,name=revision" json:"revision,omitempty"`
	Secret   string          `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *GitHubWebHookCause) Reset()                    { *m = GitHubWebHookCause{} }
func (m *GitHubWebHookCause) String() string            { return proto.CompactTextString(m) }
func (*GitHubWebHookCause) ProtoMessage()               {}
func (*GitHubWebHookCause) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{37} }

func (m *GitHubWebHookCause) GetRevision() *SourceRevision {
	if m != nil {
		return m.Revision
	}
	return nil
}

type ImageChangeCause struct {
	ImageID string              `protobuf:"bytes,1,opt,name=imageID,proto3" json:"imageID,omitempty"`
	FromRef *K8SObjectReference `protobuf:"bytes,2,opt,name=fromRef" json:"fromRef,omitempty"`
}

func (m *ImageChangeCause) Reset()                    { *m = ImageChangeCause{} }
func (m *ImageChangeCause) String() string            { return proto.CompactTextString(m) }
func (*ImageChangeCause) ProtoMessage()               {}
func (*ImageChangeCause) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{38} }

func (m *ImageChangeCause) GetFromRef() *K8SObjectReference {
	if m != nil {
		return m.FromRef
	}
	return nil
}

type OsoBuildTriggerCause struct {
	Message          string               `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	GenericWebHook   *GenericWebHookCause `protobuf:"bytes,2,opt,name=genericWebHook" json:"genericWebHook,omitempty"`
	GithubWebHook    *GitHubWebHookCause  `protobuf:"bytes,3,opt,name=githubWebHook" json:"githubWebHook,omitempty"`
	ImageChangeBuild *ImageChangeCause    `protobuf:"bytes,4,opt,name=imageChangeBuild" json:"imageChangeBuild,omitempty"`
}

func (m *OsoBuildTriggerCause) Reset()                    { *m = OsoBuildTriggerCause{} }
func (m *OsoBuildTriggerCause) String() string            { return proto.CompactTextString(m) }
func (*OsoBuildTriggerCause) ProtoMessage()               {}
func (*OsoBuildTriggerCause) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{39} }

func (m *OsoBuildTriggerCause) GetGenericWebHook() *GenericWebHookCause {
	if m != nil {
		return m.GenericWebHook
	}
	return nil
}

func (m *OsoBuildTriggerCause) GetGithubWebHook() *GitHubWebHookCause {
	if m != nil {
		return m.GithubWebHook
	}
	return nil
}

func (m *OsoBuildTriggerCause) GetImageChangeBuild() *ImageChangeCause {
	if m != nil {
		return m.ImageChangeBuild
	}
	return nil
}

type OsoBuildStatus struct {
	Phase                      string                       `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	Cancelled                  bool                         `protobuf:"varint,2,opt,name=cancelled,proto3" json:"cancelled,omitempty"`
	Reason                     string                       `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Message                    string                       `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	StartTimestamp             *K8SUnversionedTime          `protobuf:"bytes,5,opt,name=startTimestamp" json:"startTimestamp,omitempty"`
	CompletionTimestamp        *K8SUnversionedTime          `protobuf:"bytes,6,opt,name=completionTimestamp" json:"completionTimestamp,omitempty"`
	Duration                   int64                        `protobuf:"varint,7,opt,name=duration,proto3" json:"duration,omitempty"`
	OutputDockerImageReference string                       `protobuf:"bytes,8,opt,name=outputDockerImageReference,proto3" json:"outputDockerImageReference,omitempty"`
	Config                     *K8SObjectReference          `protobuf:"bytes,9,opt,name=config" json:"config,omitempty"`
	OsoBuildPhase              OsoBuildStatus_OsoBuildPhase `protobuf:"varint,10,opt,name=osoBuildPhase,proto3,enum=paas.ci.osopb3.OsoBuildStatus_OsoBuildPhase" json:"osoBuildPhase,omitempty"`
}

func (m *OsoBuildStatus) Reset()                    { *m = OsoBuildStatus{} }
func (m *OsoBuildStatus) String() string            { return proto.CompactTextString(m) }
func (*OsoBuildStatus) ProtoMessage()               {}
func (*OsoBuildStatus) Descriptor() ([]byte, []int) { return fileDescriptorModel, []int{40} }

func (m *OsoBuildStatus) GetStartTimestamp() *K8SUnversionedTime {
	if m != nil {
		return m.StartTimestamp
	}
	return nil
}

func (m *OsoBuildStatus) GetCompletionTimestamp() *K8SUnversionedTime {
	if m != nil {
		return m.CompletionTimestamp
	}
	return nil
}

func (m *OsoBuildStatus) GetConfig() *K8SObjectReference {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*K8STypeMeta)(nil), "paas.ci.osopb3.K8sTypeMeta")
	proto.RegisterType((*K8SListMeta)(nil), "paas.ci.osopb3.K8sListMeta")
	proto.RegisterType((*K8SUnversionedTime)(nil), "paas.ci.osopb3.K8sUnversionedTime")
	proto.RegisterType((*K8SResourceQuantity)(nil), "paas.ci.osopb3.K8sResourceQuantity")
	proto.RegisterType((*OwnerReference)(nil), "paas.ci.osopb3.OwnerReference")
	proto.RegisterType((*K8SObjectMeta)(nil), "paas.ci.osopb3.K8sObjectMeta")
	proto.RegisterType((*K8SObjectReference)(nil), "paas.ci.osopb3.K8sObjectReference")
	proto.RegisterType((*K8SLocalObjectReference)(nil), "paas.ci.osopb3.K8sLocalObjectReference")
	proto.RegisterType((*K8SResourceRequirements)(nil), "paas.ci.osopb3.K8sResourceRequirements")
	proto.RegisterType((*SecretKeySelector)(nil), "paas.ci.osopb3.SecretKeySelector")
	proto.RegisterType((*ConfigMapKeySelector)(nil), "paas.ci.osopb3.ConfigMapKeySelector")
	proto.RegisterType((*ResourceFieldSelector)(nil), "paas.ci.osopb3.ResourceFieldSelector")
	proto.RegisterType((*ObjectFieldSelector)(nil), "paas.ci.osopb3.ObjectFieldSelector")
	proto.RegisterType((*EnvVarSource)(nil), "paas.ci.osopb3.EnvVarSource")
	proto.RegisterType((*K8SEnvVar)(nil), "paas.ci.osopb3.K8sEnvVar")
	proto.RegisterType((*SourceControlUser)(nil), "paas.ci.osopb3.SourceControlUser")
	proto.RegisterType((*GitSourceRevision)(nil), "paas.ci.osopb3.GitSourceRevision")
	proto.RegisterType((*SourceRevision)(nil), "paas.ci.osopb3.SourceRevision")
	proto.RegisterType((*BuildPostCommitSpec)(nil), "paas.ci.osopb3.BuildPostCommitSpec")
	proto.RegisterType((*BuildOutput)(nil), "paas.ci.osopb3.BuildOutput")
	proto.RegisterType((*JenkinsPipelineBuildStrategy)(nil), "paas.ci.osopb3.JenkinsPipelineBuildStrategy")
	proto.RegisterType((*SecretSpec)(nil), "paas.ci.osopb3.SecretSpec")
	proto.RegisterType((*CustomBuildStrategy)(nil), "paas.ci.osopb3.CustomBuildStrategy")
	proto.RegisterType((*SourceBuildStrategy)(nil), "paas.ci.osopb3.SourceBuildStrategy")
	proto.RegisterType((*DockerBuildStrategy)(nil), "paas.ci.osopb3.DockerBuildStrategy")
	proto.RegisterType((*BuildStrategy)(nil), "paas.ci.osopb3.BuildStrategy")
	proto.RegisterType((*SecretBuildSource)(nil), "paas.ci.osopb3.SecretBuildSource")
	proto.RegisterType((*ImageSourcePath)(nil), "paas.ci.osopb3.ImageSourcePath")
	proto.RegisterType((*ImageSource)(nil), "paas.ci.osopb3.ImageSource")
	proto.RegisterType((*GitBuildSource)(nil), "paas.ci.osopb3.GitBuildSource")
	proto.RegisterType((*BinaryBuildSource)(nil), "paas.ci.osopb3.BinaryBuildSource")
	proto.RegisterType((*BuildSource)(nil), "paas.ci.osopb3.BuildSource")
	proto.RegisterType((*OsoCommonSpec)(nil), "paas.ci.osopb3.OsoCommonSpec")
	proto.RegisterType((*WebHookTrigger)(nil), "paas.ci.osopb3.WebHookTrigger")
	proto.RegisterType((*ImageChangeTrigger)(nil), "paas.ci.osopb3.ImageChangeTrigger")
	proto.RegisterType((*OsoBuildTriggerPolicy)(nil), "paas.ci.osopb3.OsoBuildTriggerPolicy")
	proto.RegisterType((*GenericWebHookCause)(nil), "paas.ci.osopb3.GenericWebHookCause")
	proto.RegisterType((*GitHubWebHookCause)(nil), "paas.ci.osopb3.GitHubWebHookCause")
	proto.RegisterType((*ImageChangeCause)(nil), "paas.ci.osopb3.ImageChangeCause")
	proto.RegisterType((*OsoBuildTriggerCause)(nil), "paas.ci.osopb3.OsoBuildTriggerCause")
	proto.RegisterType((*OsoBuildStatus)(nil), "paas.ci.osopb3.OsoBuildStatus")
	proto.RegisterEnum("paas.ci.osopb3.K8SNamespacePhase", K8SNamespacePhase_name, K8SNamespacePhase_value)
	proto.RegisterEnum("paas.ci.osopb3.BuildStrategy_OsoBuildStrategyType", BuildStrategy_OsoBuildStrategyType_name, BuildStrategy_OsoBuildStrategyType_value)
	proto.RegisterEnum("paas.ci.osopb3.BuildSource_OsoBuildSourceType", BuildSource_OsoBuildSourceType_name, BuildSource_OsoBuildSourceType_value)
	proto.RegisterEnum("paas.ci.osopb3.OsoBuildTriggerPolicy_OsoBuildTriggerType", OsoBuildTriggerPolicy_OsoBuildTriggerType_name, OsoBuildTriggerPolicy_OsoBuildTriggerType_value)
	proto.RegisterEnum("paas.ci.osopb3.OsoBuildStatus_OsoBuildPhase", OsoBuildStatus_OsoBuildPhase_name, OsoBuildStatus_OsoBuildPhase_value)
}
func (m *K8STypeMeta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8STypeMeta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.ApiVersion) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ApiVersion)))
		i += copy(data[i:], m.ApiVersion)
	}
	return i, nil
}

func (m *K8SListMeta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SListMeta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SelfLink) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.SelfLink)))
		i += copy(data[i:], m.SelfLink)
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	return i, nil
}

func (m *K8SUnversionedTime) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SUnversionedTime) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seconds != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintModel(data, i, uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintModel(data, i, uint64(m.Nanos))
	}
	return i, nil
}

func (m *K8SResourceQuantity) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SResourceQuantity) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.String_) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.String_)))
		i += copy(data[i:], m.String_)
	}
	return i, nil
}

func (m *OwnerReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OwnerReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.ApiVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ApiVersion)))
		i += copy(data[i:], m.ApiVersion)
	}
	if m.Controller {
		data[i] = 0x30
		i++
		if m.Controller {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *K8SObjectMeta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SObjectMeta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.GenerateName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.GenerateName)))
		i += copy(data[i:], m.GenerateName)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.SelfLink) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.SelfLink)))
		i += copy(data[i:], m.SelfLink)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if m.Generation != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintModel(data, i, uint64(m.Generation))
	}
	if m.CreationTimestamp != nil {
		data[i] = 0x42
		i++
		i = encodeVarintModel(data, i, uint64(m.CreationTimestamp.Size()))
		n1, err := m.CreationTimestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DeletionTimestamp != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintModel(data, i, uint64(m.DeletionTimestamp.Size()))
		n2, err := m.DeletionTimestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.DeletionGracePeriodSeconds != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintModel(data, i, uint64(m.DeletionGracePeriodSeconds))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			data[i] = 0x5a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			i = encodeVarintModel(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintModel(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintModel(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			data[i] = 0x62
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			i = encodeVarintModel(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintModel(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintModel(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, msg := range m.OwnerReferences {
			data[i] = 0x6a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			data[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *K8SObjectReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SObjectReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.ApiVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ApiVersion)))
		i += copy(data[i:], m.ApiVersion)
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if len(m.FieldPath) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.FieldPath)))
		i += copy(data[i:], m.FieldPath)
	}
	return i, nil
}

func (m *K8SLocalObjectReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SLocalObjectReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *K8SResourceRequirements) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SResourceRequirements) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			data[i] = 0xa
			i++
			v := m.Limits[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + msgSize + sovModel(uint64(msgSize))
			i = encodeVarintModel(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintModel(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintModel(data, i, uint64(v.Size()))
			n3, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n3
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			data[i] = 0x12
			i++
			v := m.Requests[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + msgSize + sovModel(uint64(msgSize))
			i = encodeVarintModel(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintModel(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintModel(data, i, uint64(v.Size()))
			n4, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n4
		}
	}
	return i, nil
}

func (m *SecretKeySelector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SecretKeySelector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalObjectReference != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.LocalObjectReference.Size()))
		n5, err := m.LocalObjectReference.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.Key) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	return i, nil
}

func (m *ConfigMapKeySelector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigMapKeySelector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LocalObjectReference != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.LocalObjectReference.Size()))
		n6, err := m.LocalObjectReference.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Key) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	return i, nil
}

func (m *ResourceFieldSelector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceFieldSelector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ContainerName)))
		i += copy(data[i:], m.ContainerName)
	}
	if len(m.Resource) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Resource)))
		i += copy(data[i:], m.Resource)
	}
	if m.Divisor != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.Divisor.Size()))
		n7, err := m.Divisor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ObjectFieldSelector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ObjectFieldSelector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiVersion) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ApiVersion)))
		i += copy(data[i:], m.ApiVersion)
	}
	if len(m.FieldPath) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.FieldPath)))
		i += copy(data[i:], m.FieldPath)
	}
	return i, nil
}

func (m *EnvVarSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EnvVarSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FieldRef != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.FieldRef.Size()))
		n8, err := m.FieldRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ResourceFieldRef != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.ResourceFieldRef.Size()))
		n9, err := m.ResourceFieldRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ConfigMapKeyRef != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.ConfigMapKeyRef.Size()))
		n10, err := m.ConfigMapKeyRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.SecretKeyRef != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.SecretKeyRef.Size()))
		n11, err := m.SecretKeyRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *K8SEnvVar) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *K8SEnvVar) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.ValueFrom != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.ValueFrom.Size()))
		n12, err := m.ValueFrom.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *SourceControlUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceControlUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	return i, nil
}

func (m *GitSourceRevision) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitSourceRevision) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commit) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Commit)))
		i += copy(data[i:], m.Commit)
	}
	if m.Author != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.Author.Size()))
		n13, err := m.Author.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Committer != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.Committer.Size()))
		n14, err := m.Committer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Message) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *SourceRevision) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceRevision) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Git != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.Git.Size()))
		n15, err := m.Git.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *BuildPostCommitSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildPostCommitSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Script) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Script)))
		i += copy(data[i:], m.Script)
	}
	return i, nil
}

func (m *BuildOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.To != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.To.Size()))
		n16, err := m.To.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.PushSecret != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.PushSecret.Size()))
		n17, err := m.PushSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *JenkinsPipelineBuildStrategy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *JenkinsPipelineBuildStrategy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JenkinsfilePath) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.JenkinsfilePath)))
		i += copy(data[i:], m.JenkinsfilePath)
	}
	if len(m.Jenkinsfile) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Jenkinsfile)))
		i += copy(data[i:], m.Jenkinsfile)
	}
	return i, nil
}

func (m *SecretSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SecretSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SecretSource != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.SecretSource.Size()))
		n18, err := m.SecretSource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.MountPath) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.MountPath)))
		i += copy(data[i:], m.MountPath)
	}
	return i, nil
}

func (m *CustomBuildStrategy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CustomBuildStrategy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.From.Size()))
		n19, err := m.From.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.PullSecret != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.PullSecret.Size()))
		n20, err := m.PullSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.Env) > 0 {
		for _, msg := range m.Env {
			data[i] = 0x1a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ExposeDockerSocket {
		data[i] = 0x20
		i++
		if m.ExposeDockerSocket {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ForcePull {
		data[i] = 0x28
		i++
		if m.ForcePull {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			data[i] = 0x32
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BuildAPIVersion) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.BuildAPIVersion)))
		i += copy(data[i:], m.BuildAPIVersion)
	}
	return i, nil
}

func (m *SourceBuildStrategy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SourceBuildStrategy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.From.Size()))
		n21, err := m.From.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.PullSecret != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.PullSecret.Size()))
		n22, err := m.PullSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.Env) > 0 {
		for _, msg := range m.Env {
			data[i] = 0x1a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Scripts) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Scripts)))
		i += copy(data[i:], m.Scripts)
	}
	if m.Incremental {
		data[i] = 0x28
		i++
		if m.Incremental {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ForcePull {
		data[i] = 0x30
		i++
		if m.ForcePull {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DockerBuildStrategy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DockerBuildStrategy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.From.Size()))
		n23, err := m.From.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.PullSecret != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.PullSecret.Size()))
		n24, err := m.PullSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.NoCache {
		data[i] = 0x18
		i++
		if m.NoCache {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Env) > 0 {
		for _, msg := range m.Env {
			data[i] = 0x22
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ForcePull {
		data[i] = 0x28
		i++
		if m.ForcePull {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.DockerfilePath) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(len(m.DockerfilePath)))
		i += copy(data[i:], m.DockerfilePath)
	}
	return i, nil
}

func (m *BuildStrategy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildStrategy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.DockerStrategy != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.DockerStrategy.Size()))
		n25, err := m.DockerStrategy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.SourceStrategy != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.SourceStrategy.Size()))
		n26, err := m.SourceStrategy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.CustomStrategy != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.CustomStrategy.Size()))
		n27, err := m.CustomStrategy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.JenkinsPipelineStrategy != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(m.JenkinsPipelineStrategy.Size()))
		n28, err := m.JenkinsPipelineStrategy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.OsoBuildStrategyType != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintModel(data, i, uint64(m.OsoBuildStrategyType))
	}
	return i, nil
}

func (m *SecretBuildSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SecretBuildSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Secret != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.Secret.Size()))
		n29, err := m.Secret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if len(m.DestinationDir) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.DestinationDir)))
		i += copy(data[i:], m.DestinationDir)
	}
	return i, nil
}

func (m *ImageSourcePath) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ImageSourcePath) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourcePath) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.SourcePath)))
		i += copy(data[i:], m.SourcePath)
	}
	if len(m.DestinationDir) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.DestinationDir)))
		i += copy(data[i:], m.DestinationDir)
	}
	return i, nil
}

func (m *ImageSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ImageSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.From != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.From.Size()))
		n30, err := m.From.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			data[i] = 0x12
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PullSecret != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.PullSecret.Size()))
		n31, err := m.PullSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *GitBuildSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitBuildSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Uri)))
		i += copy(data[i:], m.Uri)
	}
	if len(m.Ref) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Ref)))
		i += copy(data[i:], m.Ref)
	}
	if len(m.HttpProxy) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.HttpProxy)))
		i += copy(data[i:], m.HttpProxy)
	}
	if len(m.HttpsProxy) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.HttpsProxy)))
		i += copy(data[i:], m.HttpsProxy)
	}
	return i, nil
}

func (m *BinaryBuildSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BinaryBuildSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AsFile) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.AsFile)))
		i += copy(data[i:], m.AsFile)
	}
	return i, nil
}

func (m *BuildSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Binary != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.Binary.Size()))
		n32, err := m.Binary.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.Dockerfile) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Dockerfile)))
		i += copy(data[i:], m.Dockerfile)
	}
	if m.Git != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.Git.Size()))
		n33, err := m.Git.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Images) > 0 {
		for _, msg := range m.Images {
			data[i] = 0x2a
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ContextDir) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ContextDir)))
		i += copy(data[i:], m.ContextDir)
	}
	if m.SourceSecret != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintModel(data, i, uint64(m.SourceSecret.Size()))
		n34, err := m.SourceSecret.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			data[i] = 0x42
			i++
			i = encodeVarintModel(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OsoBuildSourceType != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintModel(data, i, uint64(m.OsoBuildSourceType))
	}
	return i, nil
}

func (m *OsoCommonSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OsoCommonSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceAccount) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ServiceAccount)))
		i += copy(data[i:], m.ServiceAccount)
	}
	if m.Source != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.Source.Size()))
		n35, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Revision != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.Revision.Size()))
		n36, err := m.Revision.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Strategy != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.Strategy.Size()))
		n37, err := m.Strategy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Output != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(m.Output.Size()))
		n38, err := m.Output.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Resources != nil {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(m.Resources.Size()))
		n39, err := m.Resources.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.PostCommit != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintModel(data, i, uint64(m.PostCommit.Size()))
		n40, err := m.PostCommit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.CompletionDeadlineSeconds != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintModel(data, i, uint64(m.CompletionDeadlineSeconds))
	}
	return i, nil
}

func (m *WebHookTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WebHookTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Secret) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Secret)))
		i += copy(data[i:], m.Secret)
	}
	if m.AllowEnv {
		data[i] = 0x10
		i++
		if m.AllowEnv {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ImageChangeTrigger) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ImageChangeTrigger) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastTriggeredImageID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.LastTriggeredImageID)))
		i += copy(data[i:], m.LastTriggeredImageID)
	}
	if m.From != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.From.Size()))
		n41, err := m.From.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *OsoBuildTriggerPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OsoBuildTriggerPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Github != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.Github.Size()))
		n42, err := m.Github.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Generic != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.Generic.Size()))
		n43, err := m.Generic.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.ImageChange != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.ImageChange.Size()))
		n44, err := m.ImageChange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.OsoBuildTriggerType != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintModel(data, i, uint64(m.OsoBuildTriggerType))
	}
	return i, nil
}

func (m *GenericWebHookCause) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenericWebHookCause) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Revision != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.Revision.Size()))
		n45, err := m.Revision.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Secret) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Secret)))
		i += copy(data[i:], m.Secret)
	}
	return i, nil
}

func (m *GitHubWebHookCause) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitHubWebHookCause) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Revision != nil {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(m.Revision.Size()))
		n46, err := m.Revision.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Secret) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Secret)))
		i += copy(data[i:], m.Secret)
	}
	return i, nil
}

func (m *ImageChangeCause) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ImageChangeCause) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ImageID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.ImageID)))
		i += copy(data[i:], m.ImageID)
	}
	if m.FromRef != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.FromRef.Size()))
		n47, err := m.FromRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *OsoBuildTriggerCause) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OsoBuildTriggerCause) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.GenericWebHook != nil {
		data[i] = 0x12
		i++
		i = encodeVarintModel(data, i, uint64(m.GenericWebHook.Size()))
		n48, err := m.GenericWebHook.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.GithubWebHook != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(m.GithubWebHook.Size()))
		n49, err := m.GithubWebHook.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.ImageChangeBuild != nil {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(m.ImageChangeBuild.Size()))
		n50, err := m.ImageChangeBuild.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *OsoBuildStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OsoBuildStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Phase)))
		i += copy(data[i:], m.Phase)
	}
	if m.Cancelled {
		data[i] = 0x10
		i++
		if m.Cancelled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintModel(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.StartTimestamp != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintModel(data, i, uint64(m.StartTimestamp.Size()))
		n51, err := m.StartTimestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.CompletionTimestamp != nil {
		data[i] = 0x32
		i++
		i = encodeVarintModel(data, i, uint64(m.CompletionTimestamp.Size()))
		n52, err := m.CompletionTimestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.Duration != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintModel(data, i, uint64(m.Duration))
	}
	if len(m.OutputDockerImageReference) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintModel(data, i, uint64(len(m.OutputDockerImageReference)))
		i += copy(data[i:], m.OutputDockerImageReference)
	}
	if m.Config != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintModel(data, i, uint64(m.Config.Size()))
		n53, err := m.Config.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.OsoBuildPhase != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintModel(data, i, uint64(m.OsoBuildPhase))
	}
	return i, nil
}

func encodeFixed64Model(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Model(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintModel(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *K8STypeMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *K8SListMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.SelfLink)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *K8SUnversionedTime) Size() (n int) {
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovModel(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovModel(uint64(m.Nanos))
	}
	return n
}

func (m *K8SResourceQuantity) Size() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *OwnerReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Controller {
		n += 2
	}
	return n
}

func (m *K8SObjectMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.GenerateName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.SelfLink)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Generation != 0 {
		n += 1 + sovModel(uint64(m.Generation))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.DeletionGracePeriodSeconds != 0 {
		n += 1 + sovModel(uint64(m.DeletionGracePeriodSeconds))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, e := range m.OwnerReferences {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *K8SObjectReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *K8SLocalObjectReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *K8SResourceRequirements) Size() (n int) {
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + l + sovModel(uint64(l))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + l + sovModel(uint64(l))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SecretKeySelector) Size() (n int) {
	var l int
	_ = l
	if m.LocalObjectReference != nil {
		l = m.LocalObjectReference.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ConfigMapKeySelector) Size() (n int) {
	var l int
	_ = l
	if m.LocalObjectReference != nil {
		l = m.LocalObjectReference.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ResourceFieldSelector) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Divisor != nil {
		l = m.Divisor.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ObjectFieldSelector) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *EnvVarSource) Size() (n int) {
	var l int
	_ = l
	if m.FieldRef != nil {
		l = m.FieldRef.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ResourceFieldRef != nil {
		l = m.ResourceFieldRef.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ConfigMapKeyRef != nil {
		l = m.ConfigMapKeyRef.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.SecretKeyRef != nil {
		l = m.SecretKeyRef.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *K8SEnvVar) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ValueFrom != nil {
		l = m.ValueFrom.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SourceControlUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *GitSourceRevision) Size() (n int) {
	var l int
	_ = l
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Author != nil {
		l = m.Author.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Committer != nil {
		l = m.Committer.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SourceRevision) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *BuildPostCommitSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *BuildOutput) Size() (n int) {
	var l int
	_ = l
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PushSecret != nil {
		l = m.PushSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *JenkinsPipelineBuildStrategy) Size() (n int) {
	var l int
	_ = l
	l = len(m.JenkinsfilePath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Jenkinsfile)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SecretSpec) Size() (n int) {
	var l int
	_ = l
	if m.SecretSource != nil {
		l = m.SecretSource.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *CustomBuildStrategy) Size() (n int) {
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PullSecret != nil {
		l = m.PullSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.ExposeDockerSocket {
		n += 2
	}
	if m.ForcePull {
		n += 2
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	l = len(m.BuildAPIVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *SourceBuildStrategy) Size() (n int) {
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PullSecret != nil {
		l = m.PullSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	l = len(m.Scripts)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Incremental {
		n += 2
	}
	if m.ForcePull {
		n += 2
	}
	return n
}

func (m *DockerBuildStrategy) Size() (n int) {
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PullSecret != nil {
		l = m.PullSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.NoCache {
		n += 2
	}
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.ForcePull {
		n += 2
	}
	l = len(m.DockerfilePath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *BuildStrategy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.DockerStrategy != nil {
		l = m.DockerStrategy.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.SourceStrategy != nil {
		l = m.SourceStrategy.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.CustomStrategy != nil {
		l = m.CustomStrategy.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.JenkinsPipelineStrategy != nil {
		l = m.JenkinsPipelineStrategy.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.OsoBuildStrategyType != 0 {
		n += 1 + sovModel(uint64(m.OsoBuildStrategyType))
	}
	return n
}

func (m *SecretBuildSource) Size() (n int) {
	var l int
	_ = l
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.DestinationDir)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ImageSourcePath) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourcePath)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.DestinationDir)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ImageSource) Size() (n int) {
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.PullSecret != nil {
		l = m.PullSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *GitBuildSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.HttpProxy)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.HttpsProxy)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *BinaryBuildSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.AsFile)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *BuildSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Binary != nil {
		l = m.Binary.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Dockerfile)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Images) > 0 {
		for _, e := range m.Images {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	l = len(m.ContextDir)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.SourceSecret != nil {
		l = m.SourceSecret.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.OsoBuildSourceType != 0 {
		n += 1 + sovModel(uint64(m.OsoBuildSourceType))
	}
	return n
}

func (m *OsoCommonSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceAccount)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Revision != nil {
		l = m.Revision.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Strategy != nil {
		l = m.Strategy.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Output != nil {
		l = m.Output.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.PostCommit != nil {
		l = m.PostCommit.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.CompletionDeadlineSeconds != 0 {
		n += 1 + sovModel(uint64(m.CompletionDeadlineSeconds))
	}
	return n
}

func (m *WebHookTrigger) Size() (n int) {
	var l int
	_ = l
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.AllowEnv {
		n += 2
	}
	return n
}

func (m *ImageChangeTrigger) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastTriggeredImageID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *OsoBuildTriggerPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Github != nil {
		l = m.Github.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Generic != nil {
		l = m.Generic.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ImageChange != nil {
		l = m.ImageChange.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.OsoBuildTriggerType != 0 {
		n += 1 + sovModel(uint64(m.OsoBuildTriggerType))
	}
	return n
}

func (m *GenericWebHookCause) Size() (n int) {
	var l int
	_ = l
	if m.Revision != nil {
		l = m.Revision.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *GitHubWebHookCause) Size() (n int) {
	var l int
	_ = l
	if m.Revision != nil {
		l = m.Revision.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ImageChangeCause) Size() (n int) {
	var l int
	_ = l
	l = len(m.ImageID)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.FromRef != nil {
		l = m.FromRef.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *OsoBuildTriggerCause) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.GenericWebHook != nil {
		l = m.GenericWebHook.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.GithubWebHook != nil {
		l = m.GithubWebHook.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ImageChangeBuild != nil {
		l = m.ImageChangeBuild.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *OsoBuildStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Cancelled {
		n += 2
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.StartTimestamp != nil {
		l = m.StartTimestamp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.CompletionTimestamp != nil {
		l = m.CompletionTimestamp.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovModel(uint64(m.Duration))
	}
	l = len(m.OutputDockerImageReference)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovModel(uint64(l))
	}
	if m.OsoBuildPhase != 0 {
		n += 1 + sovModel(uint64(m.OsoBuildPhase))
	}
	return n
}

func sovModel(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *K8STypeMeta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sTypeMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sTypeMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SListMeta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sListMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sListMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfLink = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SUnversionedTime) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sUnversionedTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sUnversionedTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Seconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nanos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SResourceQuantity) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sResourceQuantity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sResourceQuantity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.String_ = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Controller = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectMeta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenerateName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfLink = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			m.Generation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Generation |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &K8SUnversionedTime{}
			}
			if err := m.CreationTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &K8SUnversionedTime{}
			}
			if err := m.DeletionTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionGracePeriodSeconds", wireType)
			}
			m.DeletionGracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeletionGracePeriodSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerReferences = append(m.OwnerReferences, &OwnerReference{})
			if err := m.OwnerReferences[len(m.OwnerReferences)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SObjectReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sObjectReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sObjectReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SLocalObjectReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sLocalObjectReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sLocalObjectReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SResourceRequirements) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sResourceRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sResourceRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthModel
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthModel
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &K8SResourceQuantity{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Limits == nil {
				m.Limits = make(map[string]*K8SResourceQuantity)
			}
			m.Limits[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthModel
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthModel
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthModel
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &K8SResourceQuantity{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Requests == nil {
				m.Requests = make(map[string]*K8SResourceQuantity)
			}
			m.Requests[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretKeySelector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretKeySelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretKeySelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalObjectReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalObjectReference == nil {
				m.LocalObjectReference = &K8SLocalObjectReference{}
			}
			if err := m.LocalObjectReference.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigMapKeySelector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigMapKeySelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigMapKeySelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalObjectReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LocalObjectReference == nil {
				m.LocalObjectReference = &K8SLocalObjectReference{}
			}
			if err := m.LocalObjectReference.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceFieldSelector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceFieldSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceFieldSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Divisor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Divisor == nil {
				m.Divisor = &K8SResourceQuantity{}
			}
			if err := m.Divisor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectFieldSelector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectFieldSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectFieldSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvVarSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvVarSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvVarSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FieldRef == nil {
				m.FieldRef = &ObjectFieldSelector{}
			}
			if err := m.FieldRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceFieldRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceFieldRef == nil {
				m.ResourceFieldRef = &ResourceFieldSelector{}
			}
			if err := m.ResourceFieldRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigMapKeyRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigMapKeyRef == nil {
				m.ConfigMapKeyRef = &ConfigMapKeySelector{}
			}
			if err := m.ConfigMapKeyRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretKeyRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretKeyRef == nil {
				m.SecretKeyRef = &SecretKeySelector{}
			}
			if err := m.SecretKeyRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *K8SEnvVar) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: K8sEnvVar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: K8sEnvVar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueFrom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValueFrom == nil {
				m.ValueFrom = &EnvVarSource{}
			}
			if err := m.ValueFrom.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceControlUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceControlUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceControlUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitSourceRevision) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitSourceRevision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitSourceRevision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Author == nil {
				m.Author = &SourceControlUser{}
			}
			if err := m.Author.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committer == nil {
				m.Committer = &SourceControlUser{}
			}
			if err := m.Committer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceRevision) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceRevision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceRevision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitSourceRevision{}
			}
			if err := m.Git.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildPostCommitSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildPostCommitSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildPostCommitSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &K8SObjectReference{}
			}
			if err := m.To.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushSecret == nil {
				m.PushSecret = &K8SLocalObjectReference{}
			}
			if err := m.PushSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JenkinsPipelineBuildStrategy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JenkinsPipelineBuildStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JenkinsPipelineBuildStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JenkinsfilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JenkinsfilePath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jenkinsfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jenkinsfile = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SecretSource == nil {
				m.SecretSource = &K8SLocalObjectReference{}
			}
			if err := m.SecretSource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomBuildStrategy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomBuildStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomBuildStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &K8SObjectReference{}
			}
			if err := m.From.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PullSecret == nil {
				m.PullSecret = &K8SLocalObjectReference{}
			}
			if err := m.PullSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &K8SEnvVar{})
			if err := m.Env[len(m.Env)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExposeDockerSocket", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExposeDockerSocket = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePull = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &SecretSpec{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildAPIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildAPIVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceBuildStrategy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceBuildStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceBuildStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &K8SObjectReference{}
			}
			if err := m.From.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PullSecret == nil {
				m.PullSecret = &K8SLocalObjectReference{}
			}
			if err := m.PullSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &K8SEnvVar{})
			if err := m.Env[len(m.Env)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scripts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scripts = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePull = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerBuildStrategy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerBuildStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerBuildStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &K8SObjectReference{}
			}
			if err := m.From.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PullSecret == nil {
				m.PullSecret = &K8SLocalObjectReference{}
			}
			if err := m.PullSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoCache = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &K8SEnvVar{})
			if err := m.Env[len(m.Env)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForcePull", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForcePull = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerfilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DockerfilePath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildStrategy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildStrategy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildStrategy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DockerStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DockerStrategy == nil {
				m.DockerStrategy = &DockerBuildStrategy{}
			}
			if err := m.DockerStrategy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceStrategy == nil {
				m.SourceStrategy = &SourceBuildStrategy{}
			}
			if err := m.SourceStrategy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomStrategy == nil {
				m.CustomStrategy = &CustomBuildStrategy{}
			}
			if err := m.CustomStrategy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JenkinsPipelineStrategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JenkinsPipelineStrategy == nil {
				m.JenkinsPipelineStrategy = &JenkinsPipelineBuildStrategy{}
			}
			if err := m.JenkinsPipelineStrategy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsoBuildStrategyType", wireType)
			}
			m.OsoBuildStrategyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OsoBuildStrategyType |= (BuildStrategy_OsoBuildStrategyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretBuildSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretBuildSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretBuildSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &K8SLocalObjectReference{}
			}
			if err := m.Secret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationDir = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSourcePath) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSourcePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSourcePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationDir = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &K8SObjectReference{}
			}
			if err := m.From.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &ImageSourcePath{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PullSecret == nil {
				m.PullSecret = &K8SLocalObjectReference{}
			}
			if err := m.PullSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitBuildSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitBuildSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitBuildSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpProxy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsProxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpsProxy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BinaryBuildSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BinaryBuildSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BinaryBuildSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AsFile = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Binary == nil {
				m.Binary = &BinaryBuildSource{}
			}
			if err := m.Binary.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dockerfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dockerfile = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &GitBuildSource{}
			}
			if err := m.Git.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, &ImageSource{})
			if err := m.Images[len(m.Images)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContextDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContextDir = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSecret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceSecret == nil {
				m.SourceSecret = &K8SLocalObjectReference{}
			}
			if err := m.SourceSecret.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &SecretBuildSource{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsoBuildSourceType", wireType)
			}
			m.OsoBuildSourceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OsoBuildSourceType |= (BuildSource_OsoBuildSourceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsoCommonSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsoCommonSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsoCommonSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccount = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &BuildSource{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Revision == nil {
				m.Revision = &SourceRevision{}
			}
			if err := m.Revision.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Strategy == nil {
				m.Strategy = &BuildStrategy{}
			}
			if err := m.Strategy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Output == nil {
				m.Output = &BuildOutput{}
			}
			if err := m.Output.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &K8SResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PostCommit == nil {
				m.PostCommit = &BuildPostCommitSpec{}
			}
			if err := m.PostCommit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionDeadlineSeconds", wireType)
			}
			m.CompletionDeadlineSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CompletionDeadlineSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebHookTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebHookTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebHookTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowEnv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowEnv = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageChangeTrigger) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageChangeTrigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageChangeTrigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTriggeredImageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastTriggeredImageID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &K8SObjectReference{}
			}
			if err := m.From.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsoBuildTriggerPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsoBuildTriggerPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsoBuildTriggerPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Github", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Github == nil {
				m.Github = &WebHookTrigger{}
			}
			if err := m.Github.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Generic == nil {
				m.Generic = &WebHookTrigger{}
			}
			if err := m.Generic.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageChange == nil {
				m.ImageChange = &ImageChangeTrigger{}
			}
			if err := m.ImageChange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsoBuildTriggerType", wireType)
			}
			m.OsoBuildTriggerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OsoBuildTriggerType |= (OsoBuildTriggerPolicy_OsoBuildTriggerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenericWebHookCause) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericWebHookCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericWebHookCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Revision == nil {
				m.Revision = &SourceRevision{}
			}
			if err := m.Revision.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitHubWebHookCause) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitHubWebHookCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitHubWebHookCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Revision == nil {
				m.Revision = &SourceRevision{}
			}
			if err := m.Revision.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageChangeCause) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageChangeCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageChangeCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromRef == nil {
				m.FromRef = &K8SObjectReference{}
			}
			if err := m.FromRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsoBuildTriggerCause) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsoBuildTriggerCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsoBuildTriggerCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenericWebHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenericWebHook == nil {
				m.GenericWebHook = &GenericWebHookCause{}
			}
			if err := m.GenericWebHook.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GithubWebHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GithubWebHook == nil {
				m.GithubWebHook = &GitHubWebHookCause{}
			}
			if err := m.GithubWebHook.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageChangeBuild", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageChangeBuild == nil {
				m.ImageChangeBuild = &ImageChangeCause{}
			}
			if err := m.ImageChangeBuild.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OsoBuildStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OsoBuildStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OsoBuildStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancelled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cancelled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTimestamp == nil {
				m.StartTimestamp = &K8SUnversionedTime{}
			}
			if err := m.StartTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletionTimestamp == nil {
				m.CompletionTimestamp = &K8SUnversionedTime{}
			}
			if err := m.CompletionTimestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Duration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputDockerImageReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputDockerImageReference = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &K8SObjectReference{}
			}
			if err := m.Config.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsoBuildPhase", wireType)
			}
			m.OsoBuildPhase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OsoBuildPhase |= (OsoBuildStatus_OsoBuildPhase(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModel
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModel(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModel = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorModel = []byte{
	// 2645 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x5a, 0xcb, 0x6f, 0x24, 0x57,
	0xd5, 0x4f, 0x3f, 0xdc, 0xee, 0x3e, 0x7e, 0xf5, 0x5c, 0x3b, 0x49, 0xc7, 0xdf, 0x7c, 0x66, 0xa8,
	0x04, 0x48, 0x48, 0xe8, 0x89, 0x3c, 0x24, 0x9a, 0x19, 0x48, 0x90, 0xc7, 0x9e, 0x57, 0x66, 0xc6,
	0xe3, 0x5c, 0x4f, 0x82, 0x20, 0x22, 0xa2, 0x5c, 0x7d, 0xbb, 0x5d, 0xe3, 0xea, 0xba, 0x3d, 0x55,
	0xd5, 0x9e, 0x31, 0x62, 0x81, 0x90, 0xd8, 0xb0, 0x47, 0xca, 0x86, 0x15, 0x4b, 0x16, 0xac, 0x11,
	0x62, 0xc1, 0x02, 0x89, 0x25, 0x0b, 0xfe, 0x00, 0x14, 0xb6, 0x6c, 0x58, 0xb3, 0xe1, 0xdc, 0x57,
	0xbd, 0xfa, 0x76, 0xab, 0x3d, 0x0a, 0x02, 0x16, 0xb6, 0xea, 0x9e, 0x3a, 0xe7, 0xdc, 0x73, 0xcf,
	0xe3, 0x77, 0xcf, 0xbd, 0xd5, 0xb0, 0x39, 0x72, 0xdd, 0xf8, 0xb2, 0xe7, 0x5f, 0xe6, 0x31, 0x1f,
	0x1d, 0x5d, 0xb9, 0x3c, 0xe4, 0x3d, 0x16, 0x74, 0x47, 0x11, 0x4f, 0x38, 0x59, 0x15, 0xef, 0xba,
	0x9e, 0xdf, 0x55, 0xef, 0x36, 0x2f, 0x0e, 0x38, 0x1f, 0x04, 0xec, 0xb2, 0x3b, 0xf2, 0x2f, 0xbb,
	0x61, 0xc8, 0x13, 0x37, 0xf1, 0x79, 0x18, 0x2b, 0x6e, 0x67, 0x07, 0x96, 0xee, 0x5d, 0x8d, 0x1f,
	0x9d, 0x8d, 0xd8, 0x03, 0x96, 0xb8, 0x84, 0x40, 0xfd, 0xc4, 0x0f, 0x7b, 0x9d, 0xca, 0xa5, 0xca,
	0xeb, 0x2d, 0x2a, 0x9f, 0xc9, 0x16, 0x00, 0xca, 0x7e, 0xcc, 0xa2, 0x18, 0xe5, 0x3a, 0x55, 0xf9,
	0x26, 0x47, 0x71, 0x0e, 0xa5, 0x8a, 0xfb, 0x7e, 0x9c, 0x48, 0x15, 0x9b, 0xd0, 0x8c, 0x59, 0xd0,
	0xbf, 0xef, 0x87, 0x27, 0x5a, 0x4d, 0x3a, 0x26, 0xaf, 0xc3, 0x5a, 0xc4, 0x62, 0x3e, 0x8e, 0x3c,
	0x56, 0xd4, 0x57, 0x26, 0x3b, 0x7b, 0x40, 0x50, 0xe9, 0x47, 0xe1, 0xa9, 0x1a, 0xb3, 0xde, 0x23,
	0x7f, 0xc8, 0x48, 0x07, 0x16, 0x63, 0xe6, 0xf1, 0xb0, 0x17, 0x4b, 0xd5, 0x35, 0x6a, 0x86, 0x64,
	0x03, 0x16, 0x42, 0x37, 0xe4, 0xb1, 0xd4, 0xb7, 0x40, 0xd5, 0xc0, 0xf9, 0x06, 0xac, 0xa3, 0x16,
	0xaa, 0x75, 0x7f, 0x38, 0x76, 0xc3, 0xc4, 0x4f, 0xce, 0xc8, 0x4b, 0xd0, 0x88, 0x93, 0xc8, 0x0f,
	0x07, 0xda, 0x40, 0x3d, 0x72, 0x7e, 0x5e, 0x81, 0xd5, 0x87, 0x4f, 0x43, 0x16, 0x51, 0xd6, 0x67,
	0x11, 0x0b, 0x3d, 0x66, 0x75, 0x08, 0xd2, 0x42, 0x77, 0xc8, 0x3a, 0x35, 0x45, 0x13, 0xcf, 0xa4,
	0x0d, 0xb5, 0xb1, 0xdf, 0xeb, 0xd4, 0x25, 0x49, 0x3c, 0x96, 0xdc, 0xb6, 0x50, 0x76, 0x9b, 0x78,
	0x8f, 0xa6, 0x27, 0x11, 0x0f, 0x02, 0x16, 0x75, 0x1a, 0xf8, 0xbe, 0x49, 0x73, 0x14, 0xe7, 0x77,
	0x0d, 0x58, 0x41, 0xe3, 0x1f, 0x1e, 0x3d, 0x66, 0x5e, 0x62, 0x82, 0x23, 0xe7, 0xad, 0xe4, 0xe6,
	0x75, 0x60, 0x79, 0xc0, 0xd0, 0x62, 0x37, 0x61, 0xfb, 0xe2, 0x9d, 0x72, 0x67, 0x81, 0x46, 0x2e,
	0x42, 0x4b, 0xf0, 0xc6, 0x23, 0xd7, 0x33, 0x46, 0x67, 0x84, 0x42, 0xbc, 0xea, 0xa5, 0x78, 0xe9,
	0x55, 0x2d, 0x64, 0xab, 0xb2, 0x44, 0xb0, 0x61, 0x8d, 0xa0, 0x58, 0x9f, 0xb6, 0x42, 0x30, 0x2d,
	0xca, 0x70, 0xe5, 0x28, 0xe4, 0x00, 0x2e, 0x78, 0x11, 0x93, 0xcf, 0x22, 0xb6, 0x71, 0xe2, 0x0e,
	0x47, 0x9d, 0x26, 0xb2, 0x2d, 0x6d, 0x3b, 0xdd, 0x62, 0x0e, 0x77, 0x27, 0x53, 0x81, 0x4e, 0x0a,
	0x0b, 0x8d, 0x58, 0x06, 0xac, 0xa8, 0xb1, 0x35, 0xbf, 0xc6, 0x09, 0x61, 0xf2, 0x3e, 0x6c, 0x1a,
	0xe2, 0xed, 0x08, 0x9d, 0x75, 0xc0, 0x22, 0x9f, 0xf7, 0x0e, 0x75, 0x0a, 0x82, 0x5c, 0xd3, 0x0c,
	0x0e, 0xb2, 0x03, 0x8d, 0xc0, 0x3d, 0x62, 0x41, 0xdc, 0x59, 0xba, 0x54, 0x43, 0x33, 0xde, 0xb0,
	0x98, 0x91, 0x05, 0xb8, 0x7b, 0x5f, 0xf2, 0xde, 0xc4, 0x14, 0x38, 0xa3, 0x5a, 0x10, 0x17, 0xb5,
	0x94, 0xab, 0xda, 0xce, 0xb2, 0xd4, 0xd3, 0x9d, 0xad, 0x67, 0x27, 0x13, 0x50, 0xca, 0xf2, 0x2a,
	0xc8, 0x1d, 0x58, 0xe3, 0x85, 0x24, 0x8f, 0x3b, 0x2b, 0x52, 0xeb, 0x56, 0x59, 0x6b, 0xb1, 0x16,
	0x68, 0x59, 0x4c, 0x84, 0xb8, 0xef, 0x87, 0x6e, 0xe0, 0xff, 0x08, 0x1d, 0xd9, 0x59, 0x45, 0x25,
	0x98, 0xe2, 0x19, 0x65, 0xf3, 0x1a, 0x2c, 0xe5, 0x96, 0x24, 0xb2, 0xe9, 0x84, 0x9d, 0xe9, 0xf4,
	0x15, 0x8f, 0xa2, 0x6a, 0x4f, 0xdd, 0x60, 0x6c, 0xd2, 0x56, 0x0d, 0xae, 0x57, 0xaf, 0x56, 0x36,
	0xdf, 0x87, 0x76, 0x79, 0x15, 0xe7, 0x91, 0x77, 0xfe, 0x52, 0x91, 0x00, 0xa2, 0x9c, 0x32, 0xbb,
	0x9c, 0x0b, 0xe5, 0x51, 0x2d, 0x97, 0xc7, 0x17, 0x53, 0xec, 0xf3, 0x97, 0x0d, 0x5a, 0xd3, 0xf7,
	0x59, 0xd0, 0x3b, 0x70, 0x93, 0x63, 0x59, 0x35, 0x68, 0x4d, 0x4a, 0x40, 0x40, 0x7b, 0x59, 0x60,
	0x2d, 0xf7, 0xdc, 0xc0, 0xb2, 0xb4, 0x32, 0x3a, 0x38, 0xff, 0xac, 0x4a, 0x7e, 0x03, 0x80, 0x94,
	0x3d, 0x19, 0xfb, 0x11, 0x1b, 0xb2, 0x30, 0x89, 0xc9, 0x3d, 0xcc, 0x4d, 0x7f, 0xe8, 0x27, 0x02,
	0x4a, 0x45, 0xf4, 0xaf, 0x58, 0x72, 0xca, 0x26, 0xd8, 0xbd, 0x2f, 0xa5, 0x4c, 0x96, 0xca, 0x01,
	0xf9, 0x10, 0x9a, 0x11, 0xf2, 0x60, 0xd9, 0x08, 0x04, 0x16, 0xea, 0xde, 0x99, 0x57, 0x1d, 0xd5,
	0x72, 0x4a, 0x61, 0xaa, 0x66, 0xf3, 0x53, 0x4c, 0x9e, 0x6c, 0x26, 0x4b, 0xf0, 0xaf, 0xe5, 0x83,
	0xbf, 0xb4, 0xfd, 0xea, 0x8c, 0x09, 0x0d, 0xf2, 0xe7, 0x33, 0xec, 0x87, 0xb0, 0x52, 0x98, 0xfa,
	0x0b, 0x9f, 0xc1, 0xf9, 0x69, 0x05, 0x2e, 0x20, 0x12, 0x44, 0x2c, 0xb9, 0xc7, 0xce, 0x0e, 0x11,
	0x25, 0xbc, 0x84, 0x47, 0xe4, 0x13, 0xd8, 0x08, 0x2c, 0xf1, 0x93, 0xf3, 0x2e, 0x6d, 0x7f, 0xcd,
	0x32, 0x87, 0x2d, 0xdc, 0xd4, 0xaa, 0xc4, 0xac, 0xa1, 0x9a, 0xae, 0xc1, 0xf9, 0x59, 0x05, 0x36,
	0x76, 0x79, 0xd8, 0xf7, 0x07, 0x0f, 0xdc, 0xd1, 0x7f, 0xd0, 0x8e, 0xcf, 0x2a, 0xf0, 0xa2, 0x71,
	0xd6, 0x2d, 0x91, 0xcf, 0xa9, 0x21, 0xaf, 0xc1, 0x8a, 0xd8, 0xf6, 0x5c, 0x1f, 0xc1, 0x65, 0x3f,
	0xcb, 0xe0, 0x22, 0x51, 0x6c, 0x53, 0xa6, 0x54, 0xb4, 0xda, 0x74, 0x4c, 0xde, 0x83, 0xc5, 0x9e,
	0x7f, 0xea, 0xc7, 0x3c, 0x92, 0x65, 0x3a, 0x67, 0xa4, 0x8c, 0x0c, 0x36, 0x30, 0xeb, 0xca, 0xfe,
	0xa2, 0x5d, 0xc5, 0x9a, 0xae, 0x4c, 0xd4, 0x74, 0xa1, 0x52, 0xab, 0xe5, 0x4a, 0xfd, 0x6d, 0x15,
	0x96, 0x6f, 0x86, 0xa7, 0x1f, 0xbb, 0xd1, 0xa1, 0x32, 0xf2, 0x3b, 0xd0, 0x94, 0x6f, 0xd1, 0x49,
	0xda, 0xc7, 0x13, 0x56, 0x5a, 0xac, 0xa0, 0xa9, 0x10, 0xd6, 0x58, 0x3b, 0xca, 0x3b, 0x50, 0x28,
	0x52, 0x89, 0xf9, 0x95, 0xb2, 0x22, 0xab, 0xa3, 0xe9, 0x84, 0x38, 0xd9, 0x87, 0x35, 0x2f, 0x97,
	0x1b, 0x42, 0xa3, 0x72, 0xe0, 0x6b, 0x65, 0x8d, 0xb6, 0x14, 0xa2, 0x65, 0x61, 0x72, 0x13, 0x96,
	0x63, 0x93, 0xf0, 0x42, 0x59, 0x5d, 0x2a, 0xfb, 0x72, 0x59, 0xd9, 0x44, 0x51, 0xd0, 0x82, 0x98,
	0xf3, 0x04, 0x5a, 0x18, 0x30, 0xe5, 0x3d, 0x6b, 0xd7, 0x63, 0xc5, 0x7d, 0x72, 0x1d, 0x5a, 0xf2,
	0xe1, 0x56, 0xc4, 0x87, 0x7a, 0x1d, 0x17, 0xcb, 0x53, 0xe7, 0x43, 0x42, 0x33, 0x76, 0xe7, 0x3d,
	0x2c, 0x55, 0x49, 0xdc, 0x55, 0x1d, 0xd8, 0x47, 0x31, 0x9b, 0x3a, 0x35, 0x1b, 0xba, 0x7e, 0x60,
	0xa6, 0x96, 0x03, 0xe7, 0x0f, 0x58, 0xea, 0xb7, 0xfd, 0x44, 0xeb, 0x65, 0x98, 0x57, 0x22, 0x43,
	0xb0, 0xcf, 0xf4, 0xf8, 0x10, 0x31, 0xcc, 0xf4, 0x99, 0x6a, 0x84, 0xb8, 0xd2, 0x70, 0xc7, 0xc9,
	0x31, 0xa6, 0x6b, 0x75, 0x8a, 0x83, 0xca, 0xa6, 0x50, 0x2d, 0x80, 0x59, 0xd4, 0x52, 0x4a, 0x12,
	0x66, 0x92, 0x7d, 0x0e, 0xe9, 0x4c, 0x46, 0xb4, 0xd0, 0xb8, 0xb5, 0xc5, 0xee, 0x80, 0xe9, 0xfd,
	0xcb, 0x0c, 0x9d, 0xef, 0xc1, 0x6a, 0xc9, 0x7e, 0x5c, 0x7f, 0x82, 0x27, 0x03, 0xb3, 0x7e, 0xf1,
	0x4c, 0xae, 0x40, 0x6d, 0x80, 0x0b, 0x9a, 0x62, 0xf8, 0x84, 0x0f, 0xa8, 0xe0, 0x76, 0x3e, 0x81,
	0xf5, 0x1b, 0x63, 0x1f, 0x2b, 0x83, 0xc7, 0xc9, 0xae, 0x34, 0xe5, 0x70, 0xc4, 0x3c, 0x61, 0x8b,
	0x30, 0xcc, 0x95, 0x1b, 0xb2, 0x68, 0x1e, 0xcc, 0x50, 0xcc, 0xec, 0x46, 0x03, 0xb5, 0x97, 0xe0,
	0xcc, 0xe2, 0x59, 0x76, 0xed, 0x5e, 0xe4, 0x8f, 0x12, 0xbd, 0x17, 0xeb, 0x91, 0xe8, 0xda, 0x97,
	0xa4, 0xf6, 0x87, 0xe3, 0x64, 0x34, 0x4e, 0xc8, 0x36, 0x54, 0x13, 0xae, 0x4b, 0xcc, 0x99, 0xda,
	0x28, 0x65, 0x08, 0x86, 0xdc, 0xe4, 0x36, 0xc0, 0x68, 0x1c, 0x1f, 0xab, 0xc4, 0xd4, 0x8b, 0x9b,
	0x1b, 0x02, 0x73, 0xa2, 0xce, 0x63, 0xb8, 0xf8, 0x01, 0x0b, 0xb1, 0xaf, 0x88, 0x0f, 0xfc, 0x11,
	0x0b, 0x10, 0xbe, 0xa4, 0x69, 0x87, 0x89, 0xe8, 0xc6, 0x07, 0x67, 0xa2, 0x11, 0x78, 0xac, 0xde,
	0xf7, 0xfd, 0x80, 0x49, 0xe8, 0x50, 0xde, 0x2d, 0x93, 0xc9, 0x25, 0x58, 0xca, 0x91, 0x74, 0xba,
	0xe5, 0x49, 0xce, 0x53, 0x00, 0x35, 0xab, 0x74, 0xe6, 0x3d, 0x53, 0x7b, 0x2a, 0x00, 0xe7, 0xc5,
	0xf1, 0x82, 0xb0, 0xc0, 0xb6, 0x21, 0x1f, 0x87, 0x49, 0x1e, 0xdb, 0x52, 0x82, 0xf3, 0x8f, 0x2a,
	0xac, 0xef, 0x8e, 0xe3, 0x84, 0x0f, 0x8b, 0x8b, 0x7b, 0x17, 0xea, 0x7d, 0x51, 0x7b, 0xf3, 0xfb,
	0x5e, 0xf2, 0x2b, 0xef, 0x07, 0xc1, 0x73, 0x7b, 0xdf, 0x88, 0x92, 0x37, 0xa1, 0xc6, 0xc2, 0x53,
	0xcc, 0x0f, 0xd1, 0x81, 0xbc, 0x62, 0xd1, 0xa0, 0xca, 0x9f, 0x0a, 0x2e, 0xd2, 0x05, 0xc2, 0x9e,
	0x8d, 0x78, 0xcc, 0xf6, 0xb8, 0x77, 0xc2, 0x10, 0x13, 0xf0, 0x7f, 0x22, 0x8b, 0xa2, 0x49, 0x2d,
	0x6f, 0x24, 0xde, 0x73, 0x74, 0xce, 0x01, 0xce, 0x27, 0x5b, 0xbc, 0x26, 0xcd, 0x08, 0xe4, 0x9b,
	0xf2, 0x68, 0x8a, 0x46, 0xc4, 0xd8, 0xd9, 0x89, 0xe9, 0x37, 0xed, 0xa8, 0x27, 0x62, 0x45, 0x0d,
	0xab, 0x48, 0x87, 0x23, 0xe1, 0xc2, 0x9d, 0x83, 0xbb, 0x66, 0xa3, 0x51, 0x3d, 0x5f, 0x99, 0xec,
	0xfc, 0x12, 0x7d, 0xae, 0x82, 0xf3, 0xbf, 0xec, 0x73, 0x71, 0x80, 0x97, 0x55, 0x1b, 0x1b, 0xf4,
	0xd1, 0x43, 0x91, 0xee, 0x7e, 0xe8, 0xa9, 0xa6, 0xd0, 0x35, 0xfe, 0xcd, 0x93, 0x8a, 0xfe, 0x6f,
	0x94, 0xfc, 0xef, 0xfc, 0x0a, 0xfd, 0xa3, 0xc2, 0xf5, 0x5f, 0xe6, 0x1f, 0x5c, 0x72, 0xc8, 0x77,
	0x5d, 0xef, 0x58, 0x9d, 0x21, 0x9a, 0xd4, 0x0c, 0x8d, 0xe7, 0xea, 0x73, 0x79, 0x6e, 0x76, 0xf6,
	0x7d, 0x15, 0x56, 0x7b, 0x72, 0xf1, 0x29, 0xaa, 0xa8, 0xe3, 0x45, 0x89, 0xea, 0xfc, 0xba, 0x0e,
	0x2b, 0x45, 0xff, 0xd8, 0x30, 0xfe, 0x9e, 0xd1, 0x66, 0xb8, 0xa6, 0x35, 0xc0, 0x16, 0x87, 0xd3,
	0x92, 0xa8, 0x50, 0xa6, 0xba, 0x8e, 0x54, 0xd9, 0x94, 0x1e, 0xcd, 0x92, 0xdd, 0xb4, 0x24, 0x2a,
	0x94, 0x79, 0x12, 0x78, 0x52, 0x65, 0x75, 0xbb, 0x32, 0x0b, 0x3c, 0xd1, 0x92, 0x28, 0xe9, 0xc3,
	0xcb, 0x8f, 0x8b, 0x58, 0x9d, 0x6a, 0x5d, 0x90, 0x5a, 0xdf, 0x2a, 0x6b, 0x9d, 0x05, 0xed, 0x74,
	0x9a, 0x32, 0x9c, 0x67, 0x03, 0xe5, 0x0b, 0xcc, 0xe2, 0xc2, 0x4d, 0x86, 0x68, 0x75, 0x7b, 0xbb,
	0x3c, 0x49, 0x81, 0xb1, 0xfb, 0xd0, 0x22, 0x49, 0xad, 0xfa, 0x9c, 0x87, 0xb0, 0x61, 0xe3, 0x26,
	0x00, 0x0d, 0x15, 0xa8, 0xf6, 0x0b, 0xe2, 0x59, 0xf9, 0xb9, 0x5d, 0x11, 0xcf, 0xca, 0x4d, 0xed,
	0x2a, 0x59, 0x87, 0xb5, 0xd2, 0xe2, 0xda, 0x35, 0xe7, 0xc7, 0xe6, 0xfc, 0xa2, 0x74, 0x9a, 0x3e,
	0xb6, 0xa1, 0xd0, 0xeb, 0xbc, 0x3b, 0x8c, 0x16, 0x93, 0xb9, 0x8a, 0xa7, 0x2e, 0x3f, 0x94, 0x67,
	0xfb, 0x3d, 0x3f, 0xd2, 0x1b, 0x4c, 0x89, 0x8a, 0xfd, 0xc8, 0xda, 0xdd, 0x21, 0x36, 0x26, 0x6a,
	0x5e, 0xb9, 0x27, 0x62, 0x4b, 0x1e, 0xa7, 0x23, 0xd3, 0x92, 0x67, 0x94, 0xb9, 0x55, 0xff, 0x11,
	0x5b, 0x86, 0x9c, 0xee, 0xe7, 0x06, 0x89, 0x77, 0x60, 0x61, 0x84, 0xf3, 0x9a, 0x33, 0xef, 0x97,
	0xca, 0x82, 0x25, 0xfb, 0xa9, 0xe2, 0x2e, 0x61, 0x4b, 0xed, 0xb9, 0xb1, 0xc5, 0x89, 0x60, 0x15,
	0x3b, 0xae, 0x7c, 0x74, 0xc4, 0xd5, 0x44, 0xe4, 0x9b, 0x43, 0x2c, 0x3e, 0x0a, 0x4a, 0xa4, 0x4f,
	0x0a, 0x48, 0xc1, 0x47, 0x01, 0x25, 0xc7, 0x49, 0x32, 0x3a, 0x88, 0xf8, 0xb3, 0x33, 0x73, 0x1f,
	0x98, 0x12, 0x84, 0x8f, 0xc5, 0x20, 0x56, 0xaf, 0x15, 0x4a, 0xe7, 0x28, 0xce, 0x9b, 0x70, 0xe1,
	0x06, 0xba, 0x32, 0x3a, 0xcb, 0x4f, 0x8b, 0xbd, 0x99, 0x1b, 0xdf, 0x12, 0x7d, 0x8a, 0xee, 0x74,
	0xd5, 0xc8, 0xf9, 0x7d, 0x5d, 0xf7, 0x66, 0x9a, 0xcf, 0x86, 0x36, 0xd8, 0x0d, 0x1f, 0x49, 0x85,
	0xd3, 0x9a, 0xca, 0x89, 0xe9, 0xa8, 0x16, 0x10, 0xb6, 0x66, 0x00, 0xa7, 0x97, 0x92, 0xa3, 0x90,
	0xb7, 0x55, 0xb3, 0xaa, 0x30, 0x62, 0xcb, 0xd2, 0xac, 0xe6, 0x95, 0x0a, 0x56, 0x6c, 0x6f, 0x1b,
	0xbe, 0x08, 0x5a, 0x8c, 0x10, 0x20, 0x42, 0xfa, 0x7f, 0x33, 0x42, 0x4a, 0x35, 0xab, 0xb9, 0xca,
	0x65, 0xcf, 0x12, 0x91, 0x72, 0x0a, 0x79, 0x73, 0x14, 0xd9, 0x9a, 0x29, 0x1c, 0x53, 0x11, 0x5f,
	0x3c, 0x6f, 0x6b, 0x96, 0x13, 0x26, 0xdf, 0xca, 0x1a, 0x8d, 0xa6, 0x34, 0x71, 0xca, 0xf1, 0x2a,
	0xbf, 0xb4, 0xb4, 0xdf, 0xf8, 0x14, 0x48, 0x0a, 0x1d, 0xf2, 0x95, 0x04, 0xa2, 0x96, 0x04, 0xa2,
	0xae, 0x1d, 0x88, 0x24, 0x5b, 0x06, 0x43, 0xa9, 0x14, 0xb5, 0x68, 0x72, 0xf6, 0x81, 0x4c, 0x72,
	0x92, 0x45, 0xa8, 0xa1, 0xaf, 0x11, 0x7d, 0x56, 0x01, 0xf6, 0xd2, 0xe8, 0x28, 0x04, 0x52, 0xc1,
	0x45, 0x04, 0x6a, 0xc1, 0x82, 0xf4, 0x6d, 0xbb, 0x46, 0x9a, 0x50, 0xdf, 0xe7, 0x88, 0x40, 0x75,
	0xe7, 0xf3, 0x1a, 0xac, 0xa0, 0x42, 0x71, 0x66, 0xe0, 0xa1, 0x6c, 0x73, 0xb1, 0xc4, 0xf1, 0x44,
	0x73, 0xea, 0x7b, 0x6c, 0xc7, 0xf3, 0x44, 0x47, 0xaa, 0x73, 0xa9, 0x44, 0x15, 0x81, 0xcc, 0xdd,
	0x16, 0x58, 0x02, 0x59, 0xc8, 0x27, 0x7d, 0x91, 0x70, 0x5d, 0x5c, 0x32, 0xa8, 0x83, 0x8b, 0x2e,
	0xcb, 0x2d, 0xfb, 0x2e, 0x95, 0x1e, 0x6f, 0x52, 0x7e, 0x4c, 0xe3, 0x66, 0x5c, 0xdc, 0x94, 0xfe,
	0x7f, 0x26, 0xb2, 0xd3, 0x94, 0x5d, 0xd8, 0xca, 0xe5, 0xd9, 0x45, 0xef, 0x3b, 0x76, 0x5b, 0xd5,
	0xf1, 0x86, 0x6a, 0x56, 0x3c, 0x6b, 0xb7, 0xcc, 0x79, 0x3e, 0x96, 0x39, 0x67, 0xcf, 0x28, 0xdb,
	0x9d, 0x1b, 0xcd, 0x24, 0xc9, 0x2e, 0x62, 0x51, 0x7a, 0x2a, 0xd3, 0x99, 0xf9, 0xaa, 0x75, 0xfe,
	0xe2, 0xe1, 0x8d, 0xe6, 0xc4, 0xc8, 0xb7, 0xe1, 0x15, 0x3c, 0xb9, 0x8d, 0xd4, 0x3d, 0xf8, 0x1e,
	0x73, 0x7b, 0x72, 0xff, 0xd3, 0xd7, 0xe4, 0x4d, 0x79, 0x4d, 0x3e, 0x9d, 0xc1, 0xd9, 0x83, 0xd5,
	0xef, 0xb2, 0xa3, 0x3b, 0x9c, 0x9f, 0x3c, 0x8a, 0xfc, 0xc1, 0x00, 0x0f, 0xa9, 0x2f, 0x15, 0xf6,
	0x98, 0x56, 0xba, 0x75, 0x6c, 0x42, 0xd3, 0x0d, 0x02, 0xfe, 0x14, 0x1b, 0x23, 0x19, 0xd6, 0x26,
	0x4d, 0xc7, 0xce, 0x4f, 0x2a, 0x40, 0x64, 0x02, 0xed, 0x1e, 0xbb, 0xe1, 0x80, 0x19, 0x55, 0xdb,
	0xb0, 0x11, 0xb8, 0x71, 0xa2, 0x87, 0xac, 0x27, 0x59, 0xee, 0xee, 0x69, 0xc5, 0xd6, 0x77, 0xe9,
	0x76, 0x50, 0x3d, 0xdf, 0x76, 0xe0, 0xfc, 0xa6, 0x06, 0x2f, 0x9a, 0xf4, 0xd7, 0x4a, 0x0f, 0x78,
	0xe0, 0x7b, 0xf6, 0x2e, 0xeb, 0x5d, 0x68, 0x20, 0xe2, 0x1c, 0x8f, 0x8f, 0xf4, 0x3c, 0x13, 0xa9,
	0x56, 0x74, 0x0a, 0xd5, 0xdc, 0xe4, 0x2a, 0x2c, 0xca, 0xcf, 0x28, 0xbe, 0x37, 0x2d, 0x47, 0x4b,
	0x82, 0x86, 0x9d, 0xec, 0x61, 0x8f, 0x9d, 0x79, 0x48, 0x67, 0xa9, 0x63, 0x45, 0xb8, 0x82, 0x13,
	0x69, 0x5e, 0x8c, 0x9c, 0xc0, 0x3a, 0x2f, 0x2e, 0x52, 0x82, 0xc8, 0x82, 0x04, 0x91, 0x6b, 0x13,
	0x77, 0x5a, 0x36, 0x7f, 0x94, 0xa9, 0x12, 0x4f, 0x6c, 0x5a, 0x9d, 0x1f, 0xc0, 0xba, 0x85, 0x57,
	0x00, 0x07, 0x22, 0xca, 0x9d, 0xf1, 0x11, 0x82, 0xca, 0x12, 0x2c, 0xde, 0x56, 0x0b, 0x44, 0x44,
	0x59, 0xd3, 0x1b, 0xbb, 0xb2, 0x15, 0x61, 0xa5, 0x0d, 0xcb, 0xea, 0xee, 0x4a, 0x53, 0x6a, 0x52,
	0x96, 0xa3, 0x74, 0x8c, 0xf8, 0xe2, 0xc3, 0xba, 0x96, 0xd5, 0x3e, 0xdb, 0x75, 0xc7, 0x71, 0x11,
	0x07, 0x2a, 0xe7, 0xc4, 0x81, 0x2c, 0x77, 0xab, 0xf9, 0xdc, 0x75, 0x8e, 0x81, 0x28, 0x93, 0xff,
	0xed, 0x33, 0x3d, 0x86, 0x76, 0xce, 0x07, 0x6a, 0x1e, 0x3c, 0x85, 0xf8, 0x85, 0xcc, 0x37, 0x43,
	0xac, 0xdd, 0x45, 0x91, 0xbc, 0xd9, 0x6d, 0xe2, 0x3c, 0xf9, 0x6e, 0x44, 0x9c, 0x5f, 0x54, 0xb3,
	0xa6, 0x53, 0x07, 0x28, 0x9d, 0xd0, 0xdc, 0x33, 0x55, 0x0a, 0xf7, 0x4c, 0xa2, 0x87, 0x1f, 0x14,
	0x7c, 0x3e, 0xed, 0x74, 0x61, 0x89, 0x0c, 0x2d, 0x89, 0x92, 0x3b, 0xb0, 0xa2, 0xca, 0xc2, 0xe8,
	0xaa, 0xd9, 0xd7, 0x30, 0xe9, 0x7a, 0x5a, 0x14, 0x24, 0xf7, 0xa1, 0x9d, 0xcb, 0x72, 0xb9, 0x20,
	0x5d, 0x21, 0x97, 0x66, 0x54, 0x88, 0x52, 0x35, 0x21, 0xe9, 0xfc, 0xbd, 0x0e, 0xab, 0x59, 0x33,
	0xee, 0x26, 0x63, 0xf9, 0x89, 0x7a, 0x74, 0xec, 0xc6, 0xc6, 0x1f, 0x6a, 0x20, 0x9a, 0x31, 0xcf,
	0x45, 0x97, 0x06, 0x01, 0xeb, 0x69, 0x4c, 0xcb, 0x08, 0x22, 0xc4, 0x11, 0x73, 0x63, 0xbd, 0x1d,
	0x61, 0x88, 0xd5, 0x68, 0xfa, 0x2d, 0x1e, 0xf9, 0x00, 0xf7, 0xc7, 0xc4, 0x8d, 0x92, 0xec, 0x0b,
	0xe8, 0xc2, 0xdc, 0x5f, 0x40, 0x4b, 0x92, 0xe4, 0x11, 0xac, 0x67, 0xa8, 0x9d, 0x29, 0x6c, 0xcc,
	0xad, 0xd0, 0x26, 0x2e, 0x40, 0xbc, 0x37, 0x2e, 0x7c, 0x16, 0x4e, 0xc7, 0xe2, 0x83, 0xab, 0xda,
	0xde, 0x54, 0x9b, 0x20, 0x1d, 0x9d, 0x7d, 0x9a, 0x68, 0xca, 0xa5, 0xce, 0xe0, 0xc0, 0x72, 0x6a,
	0xa8, 0x3b, 0xe9, 0x19, 0xdf, 0x7d, 0x27, 0xce, 0x25, 0x4a, 0x82, 0x50, 0x58, 0x31, 0x08, 0x74,
	0x20, 0xe3, 0x04, 0x12, 0xd1, 0xde, 0x9a, 0x86, 0x68, 0x2a, 0xac, 0xe9, 0x50, 0xca, 0xd0, 0xa2,
	0x0a, 0xa7, 0x2f, 0xdb, 0x97, 0x8c, 0x20, 0x5a, 0xa1, 0x7d, 0xf6, 0x54, 0xa1, 0xd6, 0x01, 0x0b,
	0x7b, 0x7e, 0x38, 0x40, 0xd4, 0xc2, 0x01, 0x1d, 0x87, 0xa1, 0x18, 0x54, 0xc9, 0x32, 0x34, 0x77,
	0x95, 0xdb, 0x34, 0x5a, 0xdd, 0x72, 0xb1, 0x5b, 0xea, 0xb5, 0xeb, 0xa2, 0x45, 0xba, 0x19, 0x45,
	0x3c, 0x6a, 0x2f, 0x90, 0x15, 0x68, 0xed, 0x9a, 0x2c, 0x69, 0x37, 0xbe, 0xfe, 0x36, 0x5c, 0xc0,
	0x95, 0xed, 0x9b, 0xaf, 0x96, 0x6a, 0x2e, 0x14, 0xdd, 0xf1, 0x12, 0xff, 0x94, 0xe1, 0x74, 0x88,
	0x8b, 0x8f, 0x58, 0x34, 0x94, 0x67, 0x20, 0x31, 0xe5, 0x8d, 0xfd, 0x3f, 0x7d, 0xbe, 0x55, 0xf9,
	0x33, 0xfe, 0xfd, 0x15, 0xff, 0x3e, 0xfb, 0xdb, 0xd6, 0x0b, 0xf0, 0x06, 0x06, 0xab, 0xfb, 0x04,
	0xdf, 0x9e, 0x8d, 0xc5, 0x8f, 0x27, 0xba, 0x1e, 0x8f, 0x58, 0x57, 0xfd, 0x78, 0x44, 0xfe, 0x56,
	0xe4, 0x68, 0xdc, 0xd7, 0x2e, 0xb8, 0xd1, 0xba, 0x81, 0xfa, 0x1f, 0x88, 0x1f, 0x9d, 0x7c, 0xbf,
	0xa1, 0x48, 0x47, 0x0d, 0xc9, 0x73, 0xe5, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xeb, 0xce, 0x3f,
	0x9e, 0x9b, 0x22, 0x00, 0x00,
}
